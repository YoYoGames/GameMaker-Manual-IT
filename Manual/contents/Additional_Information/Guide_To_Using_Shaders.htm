<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Guida all'uso degli shader</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page that explains how to set up and use shaders" />
  <meta name="rh-index-keywords" content="Guide To Using Shaders" />
  <meta name="search-keywords" content="shaders,shader,use shaders,shader guide,shader setup,shader examples,shader example" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Guida all'uso degli shader</h1>
  <p>Gli shader sono spesso utilizzati per creare splendidi effetti grafici nei giochi. Sono anche tra le funzioni più avanzate offerte da <span data-keyref="GameMaker Name">GameMaker</span>, quindi è necessario avere una conoscenza di base della programmazione e del funzionamento di <span data-keyref="GameMaker Name">GameMaker</span> prima di iniziare a usarli.</p>
  <p>Che cos'è un <span class="notranslate">shader</span>? Inizialmente sono stati creati per fornire l'ombreggiatura per l'illuminazione (da qui il nome), ma ora vengono utilizzati per produrre un'enorme varietà di effetti. Il codice di <span class="notranslate">Shader</span> è simile al codice normale, ma viene (quasi sempre) eseguito dalla GPU, non dalla CPU. Questa differenza comporta una serie di regole e limitazioni, ma le tratteremo più avanti.</p>
  <p>Ogni <span class="notranslate">shader</span> è costituito da due componenti separati: un <strong>vertex <span class="notranslate">shader</span> </strong>e un <strong>frammento <span class="notranslate">shader</span> </strong>(chiamato anche <strong>pixel shader</strong>). Cominciamo con il vertice <span class="notranslate">shader</span>. Ogni <span class="notranslate">sprite</span> è formato da un rettangolo, ma ai computer piace disegnare triangoli, quindi i rettangoli vengono divisi in due triangoli (talvolta chiamati <em>quad</em>). Questo ci lascia con sei vertici (angoli) per <span class="notranslate">sprite</span>, ma due di questi sono uguali, quindi dobbiamo preoccuparci solo di quattro. Ora immaginiamo di avere un for <span class="notranslate">loop</span> che passa in rassegna ogni vertice ed esegue il codice all'interno del vertice <span class="notranslate">shader</span> per ciascuno di essi. Questo ci permette di modificare la posizione e il colore del vertice prima di passarlo al frammento <span class="notranslate">shader</span>, poiché il vertice <span class="notranslate">shader</span> viene eseguito prima.</p>
  <p>Ecco come si presenterebbe:</p>
  <p><img>Per il frammento <span class="notranslate">shader</span>, si può immaginare lo stesso <span class="notranslate">loop</span> di prima, ma questa volta passa in rassegna ogni singolo pixel di <span class="notranslate">sprite</span>, fornendo informazioni come la posizione e il colore di quel pixel. Nel codice del frammento <span class="notranslate">shader</span> si eseguono operazioni e calcoli per determinare il colore di quel pixel e ottenere l'effetto desiderato. Ad esempio, se si vuole che <span class="notranslate">shader</span> il proprio <span class="notranslate">sprite</span> sia in bianco e nero, si calcola la tonalità di grigio di ciascun pixel per creare l'effetto.</p>
  <p>L'aspetto è simile a questo:</p>
  <p><img>Il motivo per cui il codice <span class="notranslate">shader</span> viene solitamente eseguito dalla GPU è che è più efficiente. Le moderne CPU hanno in genere da due a otto core. Ogni core può eseguire un'attività alla volta, quindi sfruttando più core è possibile eseguire molte attività contemporaneamente. Al contrario, le moderne GPU possono eseguire migliaia e persino decine di migliaia di operazioni contemporaneamente. Questo è utile per <span class="notranslate">shaders</span> perché possiamo eseguire il codice <span class="notranslate">shader</span> di migliaia di pixel contemporaneamente. La limitazione è che abbiamo accesso solo allo stato iniziale di <span class="notranslate">sprite</span>, quindi non conosciamo le modifiche apportate ad altri pixel, poiché non possiamo sapere con certezza se il codice è già stato eseguito su di essi.</p>
  <p class="note"><strong>NOTA</strong>: <span data-keyref="GameMaker Name">GameMaker</span> consente agli utenti di scrivere <span class="notranslate">shaders</span> in <strong>GLSL</strong> (OpenGL <span class="notranslate">Shader</span> Language), <strong>HLSL</strong> (High-level <span class="notranslate">Shader</span> Language, usato quando si lavora con DirectX) e <strong>GLSL ES</strong> (un sottoinsieme di GLSL comune nei dispositivi mobili). In questo caso utilizziamo <strong>GLSL ES</strong> come linguaggio <span class="notranslate">shader</span>, poiché è quello che offre la migliore compatibilità tra le piattaforme di destinazione. In genere è quello che si vuole sempre utilizzare, a meno che non si abbiano esigenze molto specifiche e si comprendano i limiti degli altri linguaggi <span class="notranslate">shader</span>. La matematica e le tecniche dovrebbero comunque essere simili tra tutti e tre i linguaggi, a parte qualche differenza di sintassi.</p>
  <p>Il vertice <span class="notranslate">shader</span> viene eseguito per primo e, come abbiamo spiegato sopra, si occupa dei <strong>vertici</strong>. Viene utilizzato per calcolare le posizioni, le normali e le coordinate <span class="notranslate">texture</span>. Queste <span class="notranslate">shaders</span> non sono particolarmente utili in 2D, dal momento che ogni <span class="notranslate">sprite</span> quadrato è solitamente un quadrato, ma possono essere utilizzate per eseguire alcune operazioni di skewing, scalatura, ecc. Diventano molto più utili in 3D per il calcolo dell'illuminazione e le deformazioni della mesh. I frammenti <span class="notranslate">shaders</span> sono molto più interessanti e sono quelli di cui ci occuperemo maggiormente in questa sede, poiché il frammento <span class="notranslate">shader</span> è il punto in cui si ottengono le informazioni sul nostro <span class="notranslate">textures</span> e si può modificare il colore finale di ogni pixel della nostra immagine.</p>
  <p> </p>
  <h2>Variabili dello shader</h2>
  <p>Se avete creato un <span class="notranslate">shader</span> in <span data-keyref="GameMaker Name">GameMaker</span>, potreste aver notato le seguenti parole chiave nel <strong>pass-through</strong> predefinito <span class="notranslate">shader</span>. Queste parole chiave aiutano <span class="notranslate">shader</span> a capire lo scopo e l'ambito di ogni variabile:</p>
  <ul class="colour">
    <li><strong>Attributo</strong>: Sono variabili passate da OpenGL al <strong>vertex </strong>shader. Possono cambiare per ogni vertice e sono di sola lettura. Includono informazioni quali la posizione del vertice, le coordinate <span class="notranslate">texture</span>, il colore del vertice e la normale del vertice.</li>
    <li><strong>Variabili</strong>: Sono variabili utilizzate per passare i dati tra gli shader <strong>vertex </strong>e <strong>frammento </strong>. Sono disponibili per la scrittura nel vertex <span class="notranslate">shader</span>, ma sono di sola lettura nel frammento <span class="notranslate">shader</span>.</li>
    <li><strong>Uniforme</strong>: Si tratta di variabili che cambiano per <span class="notranslate">object</span> e che vengono passate dall'utente a <span class="notranslate">shader</span>. Possono essere usate sia nei vertici che nei frammenti <span class="notranslate">shaders</span>, ma sono di sola lettura.</li>
  </ul>
  <p>Vedrete anche l'uso di <strong>vec</strong> come parola chiave. Questa viene utilizzata per identificare una variabile vettoriale in <span class="notranslate">shader</span> e presto si vedrà che i vettori sono molto importanti quando si lavora con <span class="notranslate">shaders</span>. Per questo motivo sono implementati come tipo di base in GLSL. Se non li conoscete, sono un termine matematico rappresentato come una matrice con una sola colonna. Nella programmazione, di solito li rappresentiamo come una matrice in cui il numero di componenti corrisponde alla dimensione. I vettori bidimensionali e tridimensionali sono spesso usati per le posizioni, le coordinate <span class="notranslate">texture</span> o i colori senza canale alfa, mentre quelli quadridimensionali sono usati per i colori con canale alfa. Si può anche specificare se contengono booleani, numeri interi o valori in virgola mobile. La sintassi per dichiarare un vettore è la seguente:</p>
  <p class="code">vec2 firstVec;  // Two-dimensional vector of floats<br />
    vec3 secondVec; // Three-dimensional vector of floats<br />
    vec4 thirdVec;  // Four-dimensional vector of floats<br />
    <br />
    bvec3 boolVec;  // Three-dimensional vector of booleans<br />
    ivec4 intVec;   // Four-dimensional vector of integers
  </p>
  <p>Per inizializzarli, possiamo usare il costruttore per creare il vettore. È necessario fornire un numero di valori pari alla lunghezza del vettore, ma è possibile combinare scalari e vettori più piccoli per raggiungere la lunghezza desiderata. Ecco alcuni esempi:</p>
  <p class="code">// Simple 2D vector with 2 scalar values<br />
    vec2 firstVec  = vec2(2.0, 1.0);<br />
    // A 4D vector using 2 scalars and a vec2 create the 4 values<br />
    vec4 secondVec = vec4(1.0, firstVec, 0.0);<br />
    // A 3D vector using 1 component of a vec4 plus a vec2 to create the 3 values<br />
    vec3 thirdVec  = vec3(secondVec.x, firstVec);</p>
  <p>Si può anche assegnare loro un altro vettore della stessa lunghezza (o <em>far girare </em>il vettore fino a ottenere la lunghezza corretta, ma questo lo spiegheremo tra poco):</p>
  <p class="code">vec3 firstVec;<br />
    vec3 secondVec = firstVec;<br />
    vec4 thirdVec  = secondVec.xyz;<br />
    vec2 fourthVec = thirdVec.zx;</p>
  <p>Quando si accede ai componenti di un vettore in GLSL, si hanno alcune opzioni. La più semplice consiste nel trattare il vettore come un array e accedere ai componenti usando le parentesi quadre, come in questo caso:</p>
  <p class="code">vec4 myVec;<br />
    myVec[0] = 0.0;<br />
    myVec[1] = 1.0;<br />
    myVec[2] = 2.0;<br />
    myVec[3] = 1.0;</p>
  <p>Tuttavia, esiste un altro modo per accedere ai componenti con la seguente sintassi:</p>
  <p class="code">vec4 myVec;<br />
    myVec.x = 1.0;<br />
    myVec.y = 2.0;</p>
  <p>Utilizza i nomi dei componenti all'interno del vettore per accedervi. Si possono usare x, y, z o w per ottenere rispettivamente la prima, la seconda, la terza o la quarta componente. Questo metodo viene chiamato " <strong>swizzling" </strong>perché è valida anche la seguente sintassi:</p>
  <p class="code">vec4 firstVec;<br />
    vec3 secondVec = firstVec.xyz;<br />
    vec2 thirdVec  = secondVec.zy;<br />
    vec4 fourthVec = thirdVec.yxxy;</p>
  <p>Come si può vedere, possiamo usare qualsiasi combinazione di un massimo di quattro lettere per creare un vettore di quella lunghezza. Non possiamo tentare di accedere a una componente che sarebbe fuori dai limiti (per esempio, tentare di accedere a w in <span class="inline">secondVec</span> o <span class="inline">thirdVec</span>, poiché non hanno una quarta componente). Inoltre, possiamo ripetere le lettere e utilizzarle in qualsiasi ordine, purché la variabile vettoriale a cui viene assegnata abbia la stessa dimensione del numero di lettere utilizzate.</p>
  <p>Per ovvie ragioni, quando si usa swizzle per impostare i valori dei componenti, non si può usare lo stesso componente due volte. Ad esempio, il seguente esempio non è valido perché si sta cercando di impostare lo stesso componente su due valori diversi:</p>
  <p class="code">myVec.xx = vec2(2.0, 3.0);</p>
  <p>Infine, abbiamo usato <span class="inline">xyzw</span> come maschera di selezione, come di solito avviene quando si tratta di posizioni. Ci sono altre due serie di maschere che si possono usare: <span class="inline">rgba</span> (usata per i colori) o <span class="inline">stpq</span> (usata per le coordinate <span class="notranslate">texture</span> ). Internamente, non c'è alcuna differenza tra queste maschere e le usiamo solo per rendere il codice più chiaro su ciò che il vettore rappresenta in quel momento. Inoltre, non è possibile combinare le maschere swizzle nella stessa operazione, quindi questa non è valida:</p>
  <p class="code"><span class="inline"></span>myVec = otherVec.ybp;</p>
  <p>Si tratta di molte definizioni e informazioni, ma la conoscenza di queste cose è necessaria per comprendere il sito <span class="notranslate">shaders</span> stesso.</p>
  <p> </p>
  <h2>Creare uno shader</h2>
  <p>Quando si crea un <span class="notranslate">shader</span> in <span data-keyref="GameMaker Name">GameMaker</span>, vengono aperti due file: un vertice <span class="notranslate">shader</span> (<span class="inline">.vsh</span>) e un frammento <span class="notranslate">shader</span> (<span class="inline">.fsh</span>). Questo è il file <span class="notranslate">shader</span> più elementare che si possa creare, che prende un <span class="notranslate">sprite</span>, legge il <span class="notranslate">texture</span> e colora ogni pixel con quel colore. Se si specificano i colori dei vertici durante il disegno, questi colori si fondono con <span class="notranslate">texture</span>.</p>
  <p>Esaminiamo il codice di un nuovo <span class="notranslate">shader</span> <span class="notranslate">asset</span> e analizziamolo, partendo dal vertice <span class="notranslate">shader</span>.</p>
  <p class="code">// Passthrough Vertex Shader<br />
    attribute vec3 in_Position;                  // (x,y,z)<br />
    //attribute vec3 in_Normal;                  // (x,y,z)     unused in this shader.<br />
    attribute vec4 in_Colour;                    // (r,g,b,a)<br />
    attribute vec2 in_TextureCoord;              // (u,v)<br />
    <br />
    varying vec2 v_vTexcoord;<br />
    varying vec4 v_vColour;<br />
    <br />
    void main()<br />
    {<br />
        vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);<br />
        gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;<br />
        <br />
        v_vColour = in_Colour;<br />
        v_vTexcoord = in_TextureCoord;<br />
    }
  </p>
  <p>Al di fuori della funzione principale, vediamo alcune dichiarazioni di variabili e i loro qualificatori. Gli attributi ci vengono forniti da <span class="notranslate">GameMaker</span>. Quelli variabili sono creati dall'utente per passare le informazioni al frammento <span class="notranslate">shader</span>. All'interno della funzione principale, abbiamo i calcoli per trovare la posizione a video del vertice:</p>
  <ul class="colour">
    <li>Per prima cosa, creiamo un <span class="inline">vec4</span> e lo inizializziamo con le componenti della posizione, aggiungendo uno come quarta componente. In algebra lineare, la convenzione prevede che si aggiunga un uno alla quarta componente se il vettore rappresenta un punto, o uno zero se rappresenta un vettore vero e proprio.</li>
    <li>Successivamente, occorre aggiungere questa quarta componente per moltiplicarla con la matrice <span class="inline">MATRIX_WORLD_VIEW_PROJECTION</span>, che è una matrice 4x4. Questa moltiplicazione proietterà la posizione mondiale del vertice in coordinate dello schermo.</li>
    <li>Infine, passiamo il colore del vertice e la coordinata <span class="notranslate">texture</span> al frammento <span class="notranslate">shader</span> attraverso le nostre variabili variabili.</li>
  </ul>
  <p>Questo <span class="notranslate">shader</span> dovrebbe essere lasciato da solo se non si intende giocare con le posizioni dei vertici e non verrà utilizzato in nessuno degli esempi riportati di seguito, perché tutti gli effetti mostrati saranno creati utilizzando il frammento <span class="notranslate">shader</span>.</p>
  <p>Diamo ora una rapida occhiata al frammento <span class="notranslate">shader</span>:</p>
  <p class="code">// Passthrough Fragment Shader<br />
    varying vec2 v_vTexcoord;<br />
    varying vec4 v_vColour;<br />
    <br />
    void main()<br />
    {<br />
        gl_FragColor = v_vColour * texture2D( gm_BaseTexture, v_vTexcoord );<br />
    }
  </p>
  <p>Come spiegato in precedenza, l'idea alla base di un frammento <span class="notranslate">shader</span> è quella di restituire il colore del pixel corrente. Ciò avviene assegnando alla variabile <span class="inline">gl_FragColor</span> il valore finale del colore. La funzione <span class="inline">texture2D</span> prende un <span class="notranslate">texture</span> e un <span class="inline">vec2</span> con le coordinate UV che si vogliono controllare in quel <span class="notranslate">texture</span>, che restituisce un <span class="inline">vec4</span> con il colore. Nel passaggio attraverso <span class="notranslate">shader</span>, tutto ciò che si fa è prendere il colore di <span class="notranslate">texture</span> nella coordinata di questo pixel e moltiplicarlo per il colore del vertice associato a questo pixel.</p>
  <p>Ora che abbiamo il nostro primo <span class="notranslate">shader</span>, tutto ciò che dobbiamo fare per testarlo è creare un <span class="notranslate">object</span> e assegnargli un <span class="notranslate">sprite</span>, quindi nell'<strong>evento di disegno</strong> del <span class="notranslate">object</span> impostate il <span class="notranslate">shader</span> in questo modo:</p>
  <p class="code">// Draw Event<br />
    shader_set(shdrColorOverlay);<br />
    draw_self();<br />
    shader_reset();</p>
  <p>Ogni chiamata di estrazione che facciamo tra <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_set.htm"><span class="inline">shader_set()</span></a> e <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_reset.htm"><span class="inline">shader_reset()</span></a> avrà l'applicazione di <span class="notranslate">shader</span>. Qui stiamo disegnando <span class="notranslate">object</span> <span class="notranslate">sprite</span> con il nostro shader passthrough:</p>
  <p><img>Come si può intuire, questo non cambia nulla dal punto di vista visivo, poiché si tratta di un semplice pass-through <span class="notranslate">shader</span>. Tuttavia, le sezioni che seguono illustrano alcuni semplici passi che si possono compiere per modificare questo aspetto e cambiare il modo in cui il sito <span class="notranslate">sprite</span> viene disegnato. Ciascuna sezione mostra un diverso <span class="notranslate">shader</span> che si può creare e utilizzare nei propri progetti, spiegando i passaggi necessari per crearlo e il motivo per cui si opera in questo modo.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#">Shader di sovrapposizione colore</a></p>
  <div class="droptext" data-targetname="drop-down">
    <p class="dropspot">Ora possiamo modificare la base <span class="notranslate">shader</span> per fare qualcosa di diverso. Non toccheremo la parte dei vertici <span class="notranslate">shader</span> e modificheremo solo il frammento <span class="notranslate">shader</span>, e per cominciare faremo un'operazione molto semplice, cioè far sì che <span class="notranslate">shader</span> disegni il <span class="notranslate">sprite</span> usando il colore rosso. Per farlo, basta cambiare il colore <span class="inline">gl_FragColor</span> in rosso, in questo modo:</p>
    <p class="code">// Color Overlay Fragment Shader<br />
      void main()<br />
      {<br />
          gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);<br />
      }</p>
    <p class="dropspot">Si otterrà così il seguente risultato:</p>
    <p class="dropspot"><img>Non è esattamente quello che ci aspettavamo! Dobbiamo ricordare che ogni <span class="notranslate">sprite</span> è in definitiva un rettangolo, quindi, a meno che non si consideri la trasparenza, cosa che non abbiamo fatto, questo è il risultato che otterremo.</p>
    <p class="note"><strong>NOTA</strong>: Nell'immagine qui sopra, il rettangolo cambia dimensione perché lo spazio &quot;vuoto&quot; intorno alla base <span class="notranslate">sprite</span> è stato ritagliato automaticamente quando è stato inserito nella pagina <span class="notranslate">texture</span> da <span class="notranslate">GameMaker</span>, quindi a ogni fotogramma di animazione i triangoli che lo compongono sono di dimensioni diverse per adattarsi alle dimensioni ritagliate del fotogramma. Se si disattiva questa opzione, si avrà semplicemente un quadrato rosso immobile sullo schermo.</p>
    <p class="dropspot">Sopra abbiamo menzionato la funzione <span class="inline">texture2D</span>, che useremo per prendere il colore del pixel su cui stiamo lavorando e ricavarne la trasparenza. Il valore di ritorno di <span class="inline">texture2D</span> è un <span class="inline">vec4</span>, dove i componenti sono il rosso, il verde, il blu e l'alfa, in quest'ordine. Si può accedere al canale alfa mettendo un punto seguito da un <span class="inline">a</span> o da un <span class="inline">w</span> dopo il nome della variabile. Ciò corrisponde rispettivamente a RGBA e XYZW.</p>
    <p class="dropspot">Ecco il codice aggiornato:</p>
    <p class="code">// Color Overlay Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      <br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          gl_FragColor = vec4(1.0, 0.0, 0.0, texColor.a);<br />
      }
    </p>
    <p class="dropspot">Ora stiamo assegnando un nuovo <span class="inline">vec4</span> a <span class="inline">gl_FragColor</span>, in cui il canale rosso è al massimo, i canali verde e blu sono a zero e il canale alfa è lo stesso dell'originale <span class="notranslate">texture</span>. L'output appare come segue:</p>
    <p class="dropspot"><img>Ecco cosa cercavamo! Abbiamo sostituito il colore di ogni pixel con il rosso, ma abbiamo mantenuto intatto il canale alfa.</p>
    <p class="dropspot">Cambiare <span class="notranslate">shader</span> ogni volta che si vuole usare un colore diverso non è una buona idea, soprattutto perché bisognerebbe avere un <span class="notranslate">shader</span> separato per ogni colore desiderato. Invece, passeremo le informazioni sul colore a <span class="notranslate">shader</span> utilizzando un'<strong>uniforme</strong>. Per farlo, dobbiamo prima ottenere un <strong>puntatore </strong>all'uniforme. Lo faremo nell'<strong>evento Create</strong> del nostro <span class="notranslate">object</span> che ha il <span class="notranslate">sprite</span>, aggiungendo:</p>
    <p class="code">// Create Event<br />
      _uniColor = shader_get_uniform(shdrColorOverlay, &quot;u_colour&quot;);<br />
      _color    = [1.0, 1.0, 0.0, 1.0];</p>
    <p class="dropspot">Tutto ciò che dobbiamo fare è chiamare <a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_get_uniform.htm"><span class="inline">shader_get_uniform()</span></a> per ottenere un puntatore all'uniforme. I parametri da passare sono il nome <span class="notranslate">shader</span> <span class="notranslate">asset</span> (senza virgolette, perché vogliamo passare l'ID che <span class="notranslate">GameMaker</span> genera per noi) e il nome della variabile uniforme all'interno di <span class="notranslate">shader</span>, questa volta come <span class="notranslate">string</span>. Questo nome deve corrispondere esattamente a quello all'interno del codice <span class="notranslate">shader</span> perché funzioni. Abbiamo anche aggiunto una variabile colore, in modo da poterla modificare in <span class="notranslate">runtime</span> e far sì che ricordi le nostre modifiche.</p>
    <p class="dropspot">Ora il codice del nostro evento draw cambierà leggermente per passare la variabile uniforme.</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrColorOverlay);<br />
      shader_set_uniform_f_array(_uniColor, _color);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">È lo stesso codice di prima, ma prima di disegnare qualcosa, dobbiamo passare tutti i valori dell'uniforme a <span class="notranslate">shader</span>. In questo caso, passiamo il colore come array di float. Per quanto riguarda <span class="notranslate">shader</span>, lo modificheremo in modo da includere l'uniforme e utilizzarla, quindi diventerà:</p>
    <p class="code">// Color Overlay Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      uniform vec4 u_color;<br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          gl_FragColor = vec4(u_color.rgb, texColor.a);<br />
      }</p>
    <p class="dropspot">Dichiariamo una variabile con lo stesso nome della creazione <span class="notranslate">shader</span> (<span class="inline">u_color</span>) e la passiamo come le prime tre componenti del vettore <span class="inline">gl_FragColor</span>, sfruttando lo swizzling. Se compiliamo di nuovo, dovremmo vedere questo:</p>
    <p class="dropspot"><img>Ora <span class="notranslate">shader</span> è molto più utile e riutilizzabile. Sta a voi aggiungere altre funzionalità, se avete bisogno di impostare il colore (usando la variabile <span class="inline">_color</span>) durante <span class="notranslate">runtime</span>.</p>
    <p> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Shader bianco e nero</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Realizzare un <span class="notranslate">shader</span> in bianco e nero è un ottimo modo per imparare a conoscere il funzionamento di <span class="notranslate">shaders</span>. Molti principianti iniziano a provare a farlo, poiché concettualmente è abbastanza semplice: prendere ogni pixel e assegnargli una tonalità di grigio. Ma è semplice? Non proprio...</p>
    <p class="dropspot">Quando si usa il colore RGB, se tutti e tre i componenti hanno lo stesso valore, si ottiene un tono di grigio. L'approccio ingenuo alla creazione di un <span class="notranslate">shader</span> per utilizzare questa idea sarebbe quello di sommare tutti e tre i canali di colore (rosso, verde e blu) e poi dividere per tre. Poi si assegnerebbe il valore a tutti e tre i canali, creando così un tono di grigio. Ecco come appare il frammento <span class="notranslate">shader</span>:</p>
    <p class="code">// Black and white fragment shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          float gray = (texColor.r + texColor.g + texColor.b) / 3.0;<br />
          gl_FragColor = v_vColour * vec4(gray, gray, gray, texColor.a);<br />
      }
    </p>
    <p class="dropspot">Una cosa che potreste aver notato è che nel codice <span class="inline">gl_FragColor</span> stiamo moltiplicando <span class="inline">vec4</span> con qualcosa chiamato <span class="inline">v_vColour</span>. Si tratta di una variabile passata dal vertice <span class="notranslate">shader</span> che ci dice il colore del vertice associato a questo pixel. È sempre una buona idea moltiplicare il colore finale calcolato con il colore del vertice. Nella maggior parte dei casi, non servirà a nulla, ma se il colore del vertice è stato modificato in <span class="notranslate">GML</span>, questo rifletterà la modifica (usando funzioni come <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_sprite_ext.htm"><span class="inline">draw_sprite_ext()</span></a> o <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_sprite_general.htm"><span class="inline">draw_sprite_general()</span></a> per cambiare il colore <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/image_blend.htm"><span class="inline">image_blend</span></a>).</p>
    <p class="dropspot">Per quanto riguarda l'evento di estrazione, è abbastanza semplice, dato che non abbiamo un'uniforme da passare:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrBlackAndWhite);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Compiliamo e vediamo cosa abbiamo ottenuto.</p>
    <p class="dropspot"><img>Sembra già perfetto, vero? Beh, sì e no... c'è una soluzione più "corretta", poiché invece di sommare i componenti e dividere per tre, moltiplichiamo ogni componente per i valori standard NTSC per il bianco e il nero. Ecco il frammento modificato del codice <span class="notranslate">shader</span>:</p>
    <p class="code">// Black and white fragment shader<br />
      varying vec2 v_vTexcoord;<br />
      <br />
      void main()<br />
      {<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          float gray = dot(texColor.rgb, vec3(0.299, 0.587, 0.114));<br />
          gl_FragColor = vec4(gray, gray, gray, texColor.a);<br />
      }
    </p>
    <p class="dropspot">Utilizziamo il prodotto dei punti come abbreviazione per moltiplicare ogni componente di <span class="inline">texColor</span> con i pesi corretti e poi sommarli. Se non avete familiarità con il prodotto dei punti, questo è essenzialmente ciò che accade:</p>
    <p class="code">float gray = (texColor.r * 0.299) + (texColor.g * 0.587) + (texColor.b * 0.114);</p>
    <p class="dropspot">Alla fine il risultato è molto simile, ma tecnicamente più corretto.</p>
    <p class="dropspot"><img alt="Shader Vertices" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Vertices.gif" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Shader arcobaleno</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot">Il nostro ultimo esempio di <span class="notranslate">shader</span> è divertente e può essere usato per dare vita a testi, pulsanti e altro. Inizieremo in modo semplice e aggiungeremo funzionalità gradualmente, poiché questo <span class="notranslate">shader</span> è altamente personalizzabile. C'è molto da dire su questo esempio, quindi se vi sentite un po' persi o confusi, tornate indietro e rileggete alcune delle sezioni precedenti.</p>
    <p class="dropspot">La prima cosa da fare è colorare i pixel con ogni tonalità, a seconda della posizione orizzontale del pixel. Il modo per farlo è impostare la posizione x come tinta e poi convertire dal formato HSV (tinta, saturazione, luminosità) al formato RGB (rosso, verde e blu). A tale scopo, dovremo scrivere una funzione ausiliaria nel nostro frammento <span class="notranslate">shader</span> che prenda i valori HSV e restituisca un vettore RGB. Utilizzeremo una singola funzione che esegua questa operazione senza la necessità di <span class="inline">if</span> dichiarazioni, poiché l'uso di condizionali nel codice <span class="notranslate">shader</span> rende <span class="notranslate">shaders</span> <em>molto </em>lento e dovrebbe essere evitato.</p>
    <p class="dropspot">Ecco come si presenta il sito <span class="notranslate">shader</span> in questa fase:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          vec3 col = vec3(v_vTexcoord.x, 1.0, 1.0);<br />
          float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br />
          gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br />
      }
    </p>
    <p class="dropspot">Qui c'è qualcosa di più rispetto agli esempi precedenti, ma la maggior parte dovrebbe essere abbastanza ovvia. Innanzitutto, c'è la funzione <span class="inline">hsv2rgb</span>, che prende un <span class="inline">vec3</span> con il nostro colore HSV e restituisce un altro <span class="inline">vec3</span> con la nostra conversione RGB. Nella funzione principale, iniziamo creando il nostro colore HSV, dove la tinta è la nostra posizione x e lasceremo la saturazione e la luminosità a 1,0 per ora. Quindi, otteniamo l'alfa da <span class="notranslate">texture</span> in modo da colorare solo il nostro personaggio <span class="notranslate">sprite</span> e non l'intero rettangolo <span class="notranslate">sprite</span> (come abbiamo fatto nell'esempio di sovrapposizione dei colori, sopra). Infine, impostiamo il colore del frammento come il nostro colore HSV convertito in RGB con l'alfa, moltiplicato per il colore del vertice (è buona norma farlo sempre).</p>
    <p class="dropspot">Per quanto riguarda il nostro codice di disegno, al momento è banale:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Controlliamo cosa abbiamo:</p>
    <p class="dropspot"><img>Siamo vicini a ciò che vogliamo, ma c'è un problema: non vediamo tutti i colori contemporaneamente in ogni fotogramma dell'animazione e i colori sembrano cambiare in modo casuale. Il motivo è che abbiamo dato per scontato che <span class="inline">v_vTexcoord</span> ci abbia dato le coordinate di <span class="notranslate">sprite</span>, partendo dall'angolo in alto a sinistra (0,0) e finendo nell'angolo in basso a destra (1,1), che è lo standard di <span class="notranslate">shaders</span>. Tuttavia, per ottimizzare, <span class="notranslate">GameMaker</span> mette insieme il maggior numero di <span class="notranslate">textures</span> in quella che viene chiamata <a href="../Settings/Texture_Information/Texture_Pages.htm">pagina di texture</a> e, per questo motivo, questo è l'aspetto del nostro <span class="notranslate">texture</span>:</p>
    <p class="dropspot"><img>Come spiegato in precedenza, <span class="inline">v_vTexcoord</span> ci fornisce le coordinate assolute di <span class="notranslate">sprite</span> all'interno dell'intera pagina <span class="notranslate">texture</span>, ma ciò che vogliamo è un valore da 0,0 a 1,0 che copra solo il nostro attuale <span class="notranslate">sprite</span>. Questo processo si chiama <strong>normalizzazione</strong> (ottenere un valore e tradurlo in un intervallo da 0 a 1). Per normalizzare i nostri valori orizzontali, dobbiamo conoscere i valori di x0 e x1 nell'immagine precedente. Fortunatamente, <span class="notranslate">GameMaker</span> ha una funzione che ci fornisce la posizione di ogni angolo del nostro <span class="notranslate">sprite</span> all'interno della pagina <span class="notranslate">texture</span>. Per prima cosa, dobbiamo andare nell'evento Create e creare un'uniforme per passare questi dati allo shader:</p>
    <p class="code">// Create Event<br />
      _uniUV = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);</p>
    <p class="dropspot">Modifichiamo l'evento draw per ottenere i valori e passarli allo shader:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      var uv = sprite_get_uvs(sprite_index, image_index);<br />
      shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">La funzione <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Information/sprite_get_uvs.htm"><span class="inline">sprite_get_uvs()</span></a> prende un <span class="notranslate">sprite</span> e un indice e restituisce un array con tonnellate di informazioni, come le coordinate di ogni angolo, quanti pixel sono stati ritagliati per ottimizzarlo, ecc. A noi interessano due di questi valori: le coordinate destra e sinistra di <span class="notranslate">sprite</span>, che sono memorizzate rispettivamente in <span class="inline">uv[0]</span> e <span class="inline">uv[2]</span>. Nel frammento <span class="notranslate">shader</span>, utilizzeremo questi valori per calcolare la posizione orizzontale normalizzata in questo modo:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      uniform vec2 u_uv;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br />
          vec3 col = vec3(pos, 1.0, 1.0);<br />
          float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br />
          gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br />
      }
    </p>
    <p class="dropspot">Qui aggiungiamo la variabile uniforme all'inizio del file con lo stesso nome usato nell'evento Create. Quindi, calcoliamo la posizione orizzontale normalizzata traslando la nostra coordinata corrente <span class="inline">x</span> all'origine ( <span class="inline">v_vTexcoord.x - u_uv[0]</span>) e poi la dividiamo per la larghezza di <span class="notranslate">sprite</span> per ottenere un intervallo da 0 a 1 (<span class="inline">u_uv[1] - u_uv[0]</span>).</p>
    <p class="dropspot">Il risultato è:</p>
    <p class="dropspot"><img>Ecco fatto! Questo è esattamente ciò che volevamo. Possiamo vedere tutti i colori dello spettro all'interno del nostro <span class="notranslate">sprite</span>.</p>
    <p class="dropspot">Potreste essere soddisfatti, ma possiamo divertirci ancora un po' con questo <span class="notranslate">shader</span>. E se aggiungessimo un offset ai colori basato sul tempo per produrre il movimento? Per fare questo, avremo bisogno di due variabili aggiuntive per la <strong>velocità </strong>e il <strong>tempo</strong>. Avremo anche bisogno di altre due uniformi, una per ciascuna delle nuove variabili, quindi l'evento Create diventa:</p>
    <p class="code">// Create Event<br />
      _uniUV    = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);<br />
      _uniTime  = shader_get_uniform(shdrRainbow, &quot;u_time&quot;);<br />
      _uniSpeed = shader_get_uniform(shdrRainbow, &quot;u_speed&quot;);<br />
      _time  = 0;<br />
      _speed = 1.0;</p>
    <p class="dropspot">Abbiamo anche bisogno di aumentare il tempo ad ogni fotogramma, quindi nell'evento Step aggiungiamo:</p>
    <p class="code">// Step Event<br />
      _time += 1 / room_speed;</p>
    <p class="dropspot">Passiamo ora all'evento draw per inviare queste uniformi allo shader:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      var uv = sprite_get_uvs(sprite_index, image_index);<br />
      shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br />
      shader_set_uniform_f(_uniSpeed, _speed);<br />
      shader_set_uniform_f(_uniTime, _time);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Infine, torniamo al nostro <span class="notranslate">shader</span> per utilizzare effettivamente queste variabili. Moltiplicheremo la velocità con il tempo e lo aggiungeremo alla posizione, in questo modo:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      uniform vec2 u_uv;<br />
      uniform float u_speed;<br />
      uniform float u_time;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br />
          vec3 col = vec3((u_time * u_speed) + pos, 1.0, 1.0);<br />
          float alpha = texture2D(gm_BaseTexture, v_vTexcoord).a;<br />
          gl_FragColor = v_vColour * vec4(hsv2rgb(col), alpha);<br />
      }
    </p>
    <p class="dropspot">Se avete fatto tutto correttamente, dovreste vedere qualcosa di simile a questo:</p>
    <p class="dropspot"><img>Per concludere questo <span class="notranslate">shader</span>, aggiungeremo alcune altre uniformi per personalizzarlo ulteriormente. Le prime due servono a controllare la saturazione e la luminosità. La prossima la chiameremo &quot;sezione&quot; e la sua funzione è quella di permettere all'utente di passare un numero compreso tra zero e uno per determinare quale percentuale dell'intero spettro vediamo alla volta. Infine, aggiungeremo una variabile chiamata &quot;mix&quot;, che specificherà quanto vogliamo mescolare il nostro colore <span class="notranslate">shader</span> con il colore originale <span class="notranslate">texture</span> (1,0 è tutto arcobaleno, 0,0 è tutto <span class="notranslate">texture</span>). Come sempre, iniziamo aggiungendo le variabili all'evento Create:</p>
    <p class="code">// Create Event<br />
      _uniUV         = shader_get_uniform(shdrRainbow, &quot;u_uv&quot;);<br />
      _uniTime       = shader_get_uniform(shdrRainbow, &quot;u_time&quot;);<br />
      _uniSpeed      = shader_get_uniform(shdrRainbow, &quot;u_speed&quot;);<br />
      _uniSection    = shader_get_uniform(shdrRainbow, &quot;u_section&quot;);<br />
      _uniSaturation = shader_get_uniform(shdrRainbow, &quot;u_saturation&quot;); <br />
      _uniBrightness = shader_get_uniform(shdrRainbow, &quot;u_brightness&quot;);<br />
      _uniMix        = shader_get_uniform(shdrRainbow, &quot;u_mix&quot;);<br />
      <br />
      _time  = 0;<br />
      _speed = 1.0;<br />
      _section = 0.5;<br />
      _saturation = 0.7;<br />
      _brightness = 0.8;<br />
      _mix = 0.5;
    </p>
    <p class="dropspot">Il nostro evento di sorteggio cambia per includere queste uniformi in questo modo:</p>
    <p class="code">// Draw Event<br />
      shader_set(shdrRainbow);<br />
      var uv = sprite_get_uvs(sprite_index, image_index);<br />
      shader_set_uniform_f(_uniUV, uv[0], uv[2]);<br />
      shader_set_uniform_f(_uniSpeed, _speed);<br />
      shader_set_uniform_f(_uniTime, _time);<br />
      shader_set_uniform_f(_uniSaturation, _saturation);<br />
      shader_set_uniform_f(_uniBrightness, _brightness);<br />
      shader_set_uniform_f(_uniSection, _section);<br />
      shader_set_uniform_f(_uniMix, _mix);<br />
      draw_self();<br />
      shader_reset();</p>
    <p class="dropspot">Per quanto riguarda <span class="notranslate">shader</span>, dobbiamo passare la saturazione e la luminosità al colore, che influenzerà il colore generato dalla nostra funzione helper. La sezione deve essere moltiplicata per la nostra posizione per ridurre l'intervallo. Verrà inoltre acquisito l'intero colore <span class="notranslate">texture</span>, in modo da poter calcolare il nostro colore finale mescolando il colore <span class="notranslate">texture</span> con la conversione RGB del nostro colore. L'ultimo parametro della funzione mix determina la quantità di secondo colore da aggiungere. Questo è il nostro codice finale <span class="notranslate">shader</span>:</p>
    <p class="code">// Fragment Shader<br />
      varying vec2 v_vTexcoord;<br />
      varying vec4 v_vColour;<br />
      <br />
      uniform vec2 u_uv;<br />
      uniform float u_speed;<br />
      uniform float u_time;<br />
      uniform float u_saturation;<br />
      uniform float u_brightness;<br />
      uniform float u_section;<br />
      Uniform float u_mix;<br />
      <br />
      vec3 hsv2rgb(vec3 c) <br />
      {<br />
          vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);<br />
          vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);<br />
          return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);<br />
      }<br />
      <br />
      void main()<br />
      {<br />
          float pos = (v_vTexcoord.x - u_uv[0]) / (u_uv[1] - u_uv[0]);<br />
          vec4 texColor = texture2D(gm_BaseTexture, v_vTexcoord);<br />
          <br />
          vec3 col = vec3(u_section * ((u_time * u_speed) + pos), u_saturation, u_brightness);<br />
        vec4 finalCol = mix(texColor, vec4(hsv2rgb(col), texColor.a), u_mix);<br />
          <br />
          gl_FragColor = v_vColour * finalCol;<br />
      }
    </p>
    <p class="dropspot">Il risultato finale è questo!</p>
    <p class="dropspot"><img alt="Shader Fragments" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Shader_Fragments.gif" /></p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>Questa è la fine di questa breve guida e ora dovreste aver compreso meglio il funzionamento di <span class="notranslate">shaders</span> e alcuni degli usi che se ne possono fare. Dovreste prendervi tutto il tempo necessario per giocare con i <span class="notranslate">shaders</span> che avete creato seguendo questa guida e provare a sperimentarli per fare altre cose: che ne dite di creare un <span class="notranslate">shader</span> blur, o un <span class="notranslate">shader</span> che crea uno schermo monocromatico in stile gameboy? - <span class="notranslate">shaders</span> sono uno strumento incredibilmente potente per aggiungere complessità visiva e stile ai vostri giochi.</p>
  <p class="note">Ringraziamo <a href="https://twitter.com/AleHitti">Alejandro Hitti</a> e <strong>Amazon</strong> per averci permesso di riprodurre questa guida. La versione originale è disponibile sul <a href="https://developer.amazon.com/es/blogs/appstore/post/acefafad-29ba-4f31-8dae-00805fda3f58/intro-to-shaders-and-surfaces-with-gamemaker-studio-2">blog degli sviluppatori di Amazon</a>.</p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Indietro: <a href="Additional_Information.htm">Informazioni aggiuntive</a></div>
        <div style="float:right">Avanti: <a href="Guide_To_Primitives_And_Vertex_Building.htm">Guida alle primitive e alla costruzione dei vertici</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Tutti i diritti riservati</span></h5>
  </div>
  <!-- KEYWORDS
Shaders
Using Shaders
Shader Guide
Guide To Using Shaders
-->
  <!-- TAGS
using_shaders
-->
</body>
</html>