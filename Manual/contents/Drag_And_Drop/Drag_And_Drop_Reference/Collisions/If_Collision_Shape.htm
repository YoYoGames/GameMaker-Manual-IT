<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Se la forma della collisione</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../../assets/css/default.css" type="text/css" />
  <script src="../../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page that explains the If Collision Shape action" />
  <meta name="rh-index-keywords" content="GML Visual Action - If Collision Shape" />
  <meta name="search-keywords" content="If Collision Shape" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1><img> Se la forma della collisione</h1>
  <p>Questa azione è usata per controllare e vedere se c'è una collisione con un'istanza di un dato <span class="notranslate">object</span> all'interno di una data area sagomata o lungo una linea. Si dà la forma (rettangolo, ellisse o linea), l'indirizzo <span class="notranslate">object</span> da controllare, e poi si forniscono le coordinate per
    gli angoli superiore sinistro e inferiore destro della forma da utilizzare, o nel caso di una linea, le posizioni di inizio e fine. Queste possono essere posizioni assolute all'interno del gioco <span class="notranslate">room</span>, o posizioni relative all'istanza che esegue l'azione. Potete vedere come
    funziona nell'immagine qui sotto:</p>
  <p><img>Come potete vedere, i risultati dipendono dalla maschera di collisione dell'istanza
    che viene controllata, il che significa che l'istanza di <span class="notranslate">object</span> che state cercando <i>deve</i> avere un <span class="notranslate">sprite</span> assegnato al <span class="inline">sprite_index</span>, o un <span class="notranslate">sprite</span> assegnato al <span class="inline">mask_index</span>. Se non lo fa, allora non sarà rilevato da queste funzioni,
    indipendentemente dal fatto che stia disegnando un <span class="notranslate">sprite</span> o meno. Vale la pena notare che qualsiasi istanza che cade completamente all'interno dei confini impostati per la forma ellisse o rettangolo restituirà anche una collisione. L'azione valuterà <span class="inline">true</span> se
    viene rilevata una collisione, o <span class="inline">false</span> altrimenti, sebbene si possa anche controllare il flag <b>Not</b> per verificare se <i>non</i> c'è una collisione con l'area di forma data, e l'azione valuterà quindi solo come <span class="inline">true</span> se <i>non</i> vengono trovate collisioni
    altrimenti valuterà come <span class="inline">false</span>. Puoi anche impostare l'opzione <b>Exclude Self</b> per escludere l'istanza chiamante dal controllo delle collisioni.</p>
  <p>Poi puoi selezionare/deselezionare l'opzione per <b>restituire la lista</b>. Selezionando questo significa che l'azione creerà e popolerà un <a href="../Data_Structures/Data_Structure_Actions.htm">elenco</a><span> </span>struttura dati con <i>tutte le istanze</i>in collisione
    con la forma e imposterà la variabile <b>Target</b> all'ID della lista DS. Quando è deselezionato, imposterà la variabile <b>Target</b> solo su un valore inferiore a 0 quando non viene rilevata alcuna collisione, o sul valore ID unico di <i>una</i> delle istanze in collisione
    (nota che se più istanze sono in collisione allora non hai modo di sapere quale ID di istanza sarà restituito quando non usi una lista).</p>
  <p>Se avete scelto di restituire una lista - e la variabile Target <i>non</i> è impostata su <b>Temp</b> - allora potete anche selezionare l'opzione <b>Free Target</b>. Quando è impostata su <span class="inline">true</span>, allora l'elenco contenuto nella variabile target sarà distrutto e
    un nuovo elenco creato (e restituito alla variabile target) ogni volta che si chiama l'azione. In questo modo si può riutilizzare la stessa variabile senza preoccuparsi di perdite di memoria, poiché, se <i>non</i> si seleziona l'opzione <b>Free Target</b>, si diventa responsabili
    di distruggere la lista prima di utilizzare nuovamente la variabile nell'azione. Si noti che, <i>indipendentemente</i> dal fatto che questa opzione sia selezionata o meno, se avete impostato l'azione su <b>Return List</b>, allora la variabile target <i>conterrà sempre un ID di lista</i>,
    e come tale, questo dovrà essere liberato quando l'istanza viene distrutta o il <span class="notranslate">room</span> finisce (si può usare l'evento <a href="../../../The_Asset_Editors/Object_Properties/Object_Events.htm"><b>Pulire</b></a> per questo, per esempio, insieme all'azione <a href="../Data_Structures/Free_Data_Structure.htm">Free Data Structure</a><span> </span>).
    Vale la pena notare che è possibile impostare l'opzione <b>Free Target</b> per utilizzare una variabile predefinita o un'espressione e quindi controllare quando la struttura dati dell'elenco viene liberata impostando la variabile altrove (o avendo diversi risultati per l'espressione)
    purché valuti <span class="inline">true</span>/<span class="inline">false</span>.</p>
  <p>Infine, si fornisce la variabile <b>Target</b> che si vuole contenere il valore restituito o l'ID dell'elenco. Se si contrassegna la variabile Target per contenere il valore restituito come una variabile <b>Temp</b> (locale), allora l'azione creerà questa variabile per contenere
    il valore restituito <i>solo</i> fino alla fine dell'evento, in questo caso l'opzione Free Target non fa nulla e sarai responsabile della distruzione dell'elenco DS se questa opzione è stata selezionata. Se non viene fornita alcuna variabile di destinazione e l'opzione <b>Return List</b> è selezionata, non verrà creata alcuna lista.</p>
  <p class="note"><b>IMPORTANTE!</b> Le collisioni saranno registrate solo per quelle istanze che hanno una maschera di collisione valida, cioè: hanno un <span class="notranslate">sprite</span> assegnato al <span class="inline">sprite_index</span>, o un <span class="notranslate">sprite</span> assegnato al <span class="inline">mask_index</span>. Se le istanze del <span class="notranslate">object</span> che vengono
    controllata in questa azione non hanno una maschera di collisione, allora la collisione non verrà rilevata, indipendentemente da ciò che l'istanza sta disegnando in quel momento.</p>
  <p>Notate che per aggiungere azioni in un blocco &quot;<span class="inline">if</span>&quot;, esse devono essere lasciate cadere a <i>lato</i> dell'azione, come mostrato nell'immagine qui sotto:</p>
  <p><img alt="If Collision Shape Icon" class="icon" height="32" src="../../../assets/Images/Scripting_Reference/Drag_And_Drop/Reference/Collisions/i_Collision_Shape.png" width="32" /></p>
  <p> </p>
  <h4>Sintassi dell'azione:</h4>
  <p><img alt="Example of different collision shapes" class="center" src="../../../assets/Images/Scripting_Reference/Drag_And_Drop/Reference/Collisions/collision_shape_example.png" /></p>
  <h4>Argomenti:</h4>
  <table>
    <tbody>
      <tr>
        <th>Argomento</th>
        <th>Descrizione</th>
      </tr>
      <tr>
        <td><span class="notranslate">Shape</span></td>
        <td>La forma da usare</td>
      </tr>
      <tr>
        <td><span class="notranslate">Object</span></td>
        <td>Il <span class="notranslate">object</span> per controllare le istanze di</td>
      </tr>
      <tr>
        <td><span class="notranslate">x1</span></td>
        <td>La posizione x da cui partire</td>
      </tr>
      <tr>
        <td><span class="notranslate">y1</span></td>
        <td>La posizione y da cui partire</td>
      </tr>
      <tr>
        <td><span class="notranslate">x2</span></td>
        <td>La posizione x a cui terminare</td>
      </tr>
      <tr>
        <td><span class="notranslate">y2</span></td>
        <td>La posizione y a cui finire</td>
      </tr>
      <tr>
        <td><span class="notranslate">Free Target</span></td>
        <td>Può essere impostato su una variabile o espressione, o impostato su <span class="inline">true</span>/<span class="inline">false</span> per controllare la liberazione della memoria dell'elenco quando si riutilizza una variabile dell'elenco</td>
      </tr>
      <tr>
        <td><span class="notranslate">Target</span></td>
        <td>La variabile a cui puntare per il valore di ritorno dell'azione</td>
      </tr>
    </tbody>
  </table>
  <p> </p>
  <h4>Esempio:</h4>
  <p><img>Il codice del blocco d'azione di cui sopra controlla una collisione con qualsiasi istanza di <span class="notranslate">object</span> &quot;
   <span class="inline">obj_Enemy</span>&quot; entro un cerchio di 100px intorno alla posizione dell'istanza chiamante. L'azione genera una lista di tutte le istanze trovate in collisione e memorizza l'ID della lista nella variabile Target. Se l'azione valuta a
    <span class="inline">true</span> allora la lista viene passata in rassegna e ogni istanza con il suo ID memorizzato nella lista ha la sua variabile &quot;<span class="inline">hp</span>&quot; ridotta di 1. La lista DS viene quindi liberata.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Indietro: <a href="Collision_Actions.htm">Azioni di collisione</a></div>
        <div style="float:right">Il prossimo: <a href="If_Collision_Point.htm">Se punto di collisione</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Tutti i diritti riservati</span></h5>
  </div>
  <!-- KEYWORDS
Action - If Collision Shape
-->
  <!-- TAGS
action_if_collision_shape
-->
</body>
</html>