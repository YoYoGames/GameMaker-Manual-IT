<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Movimento e controlli</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Some basic code and GML Visualto show people how to move things around within a game." />
  <meta name="rh-index-keywords" content="Quick Start - Movement And Controls" />
  <meta name="search-keywords" content="movement,controls" />
  <meta name="robots" content="NOODP" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Movimento e controlli</h1>
  <p>La <a href="Drawing.htm">sezione precedente</a> di questa Guida rapida ha fornito alcuni esempi per disegnare sullo schermo, ma disegnare e basta non serve a molto se non si possono anche muovere... quindi in questa sezione vi forniremo alcuni esempi di movimento per il vostro <span class="notranslate">objects</span>, oltre ad alcuni schemi di controllo di base per diversi tipi di giochi. Tutti gli esempi sono forniti utilizzando <span class="notranslate">GML</span> Visual e <span class="notranslate">GML</span> Code, quindi potete usare quello con cui vi sentite più a vostro agio. Non spiegheremo le cose in modo troppo approfondito, perché vogliamo che iniziate a creare il più rapidamente possibile, quindi vi invitiamo a esplorare i link man mano che procedete e a usare la funzione &quot;ricerca&quot; del manuale per cercare informazioni aggiuntive su qualsiasi cosa non vi sia chiara.</p>
  <p>Prima di andare avanti, è consigliabile creare un nuovo progetto ( <span class="notranslate">GML</span> o <span class="notranslate">GML</span> Visual) dalla <a href="../Introduction/The_Start_Page.htm">pagina iniziale</a>, aggiungere (o creare) alcuni <span class="notranslate">sprites</span> e uno o due <span class="notranslate">object</span> - poiché vi forniremo del codice da testare con questi - e assicurarsi che il progetto abbia un <span class="notranslate">room</span> in cui inserire le istanze. Non preoccupatevi troppo dell'aspetto di <span class="notranslate">sprites</span>, anche un semplice quadrato bianco andrà bene, e una volta che avrete preparato tutto potrete iniziare a lavorare sugli esempi elencati di seguito.</p>
  <p> </p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down" href="#">Muoversi verso il mouse</a></p>
  <div class="droptext" data-targetname="drop_down">
    <p class="dropspot">Uno dei modi più semplici per far muovere e interagire un <span class="notranslate">object</span> con il giocatore è quello di utilizzare il mouse. In questo esempio vi mostreremo come utilizzare un codice di base per far muovere un <span class="notranslate">object</span> verso il punto in cui l'utente ha cliccato il tasto sinistro del mouse <img>.</p>
    <p class="dropspot">Per iniziare, aprite un sito <span class="notranslate">object</span>, assegnategli un <span class="notranslate">sprite</span> e poi dategli un <strong>evento Global Left Mouse Down</strong>:</p>
    <p class="dropspot"><img alt="LMB Icon" class="icon" src="../assets/Images/Icons/Icon_LMB.png" /></p>
    <p class="dropspot">Utilizziamo gli eventi <strong>globali </strong>del mouse perché rilevano un clic in qualsiasi punto del sito <span class="notranslate">room</span>, mentre gli eventi normali del mouse rilevano un clic solo se il mouse fa effettivamente clic all'interno del <a class="glossterm" data-glossterm="riquadro di delimitazione" href="#">rettangolo di selezione dell</a>'istanza. In questo evento vogliamo aggiungere queste azioni o codice:</p>
    <p class="dropspot"><img alt="Adding The Mouse Left Button Down Event" class="center" src="../assets/Images/QS_Guide/QS_Add_GlobalLMBDownEvent.png" /></p>
    <p class="code">move_towards_point(mouse_x, mouse_y, 2);</p>
    <p class="dropspot">Qui stiamo dicendo all'istanza di spostarsi verso una posizione sullo schermo, in questo caso le posizioni &quot;<span class="inline">mouse_x</span>&quot; e &quot;<span class="inline">mouse_y</span>&quot; (&quot;<span class="inline">mouse_x</span>&quot; e &quot;<span class="inline">mouse_y</span>&quot; sono <a class="glossterm" data-glossterm="variabile" href="#">variabili</a> <strong>incorporate </strong> che contengono sempre la posizione corrente del cursore del mouse). La variabile visuale <span class="notranslate">GML</span> lo fa impostando le variabili &quot;<span class="inline">direction</span>&quot; e &quot; <span class="inline">speed</span>&quot;. <a href="../GameMaker_Language/GML_Reference/Asset_Management/Instances/Instance_Variables/Instance_Variables.htm"><strong>Variabili dell'istanza</strong></a>, mentre <span class="notranslate">GML</span> lo fa utilizzando la funzione <a href="../GameMaker_Language/GML_Reference/Movement_And_Collisions/Movement/move_towards_point.htm"><span class="inline">move_towards_point()</span></a> (che imposta anche le variabili <span class="inline">speed </span>e <span class="inline">direction </span>, in un'unica funzione facile da usare).</p>
    <p class="dropspot">Posizionate un'istanza di questo <span class="notranslate">object</span> in un <span class="notranslate">room</span> e premete il pulsante Play <img>, quindi fate clic su <img> intorno al <span class="notranslate">room</span> per far muovere l'istanza verso il mouse:</p>
    <p class="dropspot"><img>Ottimo! L'istanza di <span class="notranslate">object</span> si sposta ora verso il punto in cui si è fatto clic e, se si tiene premuto il pulsante, l'istanza continua a seguire il cursore del mouse. Tuttavia, c'è un problema... Dopo aver fatto clic una volta e aver rilasciato il pulsante, l'istanza continuerà a muoversi e alla fine lascerà il sito <span class="notranslate">room</span>! Ci sono diversi modi per risolvere questo problema e quello che sceglierete dipenderà da ciò che volete fare, ma la soluzione più semplice per ora è semplicemente aggiungere un evento <strong>Global Mouse Button Released</strong>, quindi aggiungetelo ora a <span class="notranslate">object</span> e dategli questo codice:</p>
    <p class="dropspot"><img alt="GML VisualTo Move Instance Towards Mouse" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_1.png" /></p>
    <p class="code">speed = 0;</p>
    <p class="dropspot">In questo modo, l'istanza seguirà il cursore del mouse solo per tutto il tempo in cui viene tenuto premuto il pulsante del mouse e, quando si rilascia il pulsante, smetterà di muoversi. Premete Play <img> e provatela subito.</p>
    <p class="dropspot">Prima di lasciare questo esempio, c'è un'ultima questione da risolvere... Se si fa clic e si <em>tiene premuto </em>il pulsante del mouse, ma non si sposta il cursore, l'istanza si sposta verso il cursore e poi &quot;vibra&quot; intorno ad esso. Questo accade perché l'istanza si muove a una velocità superiore a 1 pixel alla volta e quindi &quot;sfora&quot; la posizione e cerca di tornare indietro, per poi sforare di nuovo, ecc... (se il problema non è immediatamente evidente, la velocità di movimento deve essere pari a 5 o qualcosa di simile).</p>
    <p class="dropspot"><img>Per risolvere questo problema è necessario aggiungere un <strong>evento Step</strong> a <span class="notranslate">object</span> con questo codice:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">var _dist = point_distance(x, y, mouse_x, mouse_y);<br />
      <br />
      if _dist &lt;= speed<br />
      {<br />
          speed = 0;<br />
      }
    </p>
    <p class="dropspot">Qui controlliamo semplicemente la distanza tra l'istanza e la posizione del mouse e se è uguale o inferiore alla velocità corrente, impostiamo la velocità a 0. In questo modo l'istanza si ferma quando è sufficientemente vicina alla posizione del mouse e non si verifica quel fastidioso problema della &quot;vibrazione&quot;.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down1" href="#">Movimento a 4 e 8 vie con la tastiera</a></p>
  <div class="droptext" data-targetname="drop_down1">
    <p class="dropspot"><a href="What_Is_Programming_.htm">All'inizio di questa guida</a>, abbiamo mostrato la seguente azione e il codice per spostare un'istanza a destra di due pixel a ogni passo di gioco:</p>
    <p class="dropspot"><img alt="LMB Icon" class="icon" src="../assets/Images/Icons/Icon_LMB.png" /></p>
    <p class="code">x = x + 2;</p>
    <p class="dropspot">Questo tipo di movimento è chiamato movimento <strong>posizionale </strong>, in quanto stiamo essenzialmente raccogliendo l'istanza e la riposizioniamo in una nuova posizione ogni volta che il codice viene eseguito. In questo esempio mostreremo come utilizzare questo tipo di movimento per spostare un'istanza in 4 direzioni: su, giù, sinistra e destra.</p>
    <p class="dropspot">Per cominciare, aprite un <span class="notranslate">object</span> e assegnategli un <span class="notranslate">sprite</span>. A questo punto potremmo aggiungere vari <strong>eventi di tastiera</strong> e in ognuno di essi far muovere l'istanza nella direzione desiderata; tuttavia, vogliamo che il giocatore sia in grado di muoversi in una sola direzione alla volta e farlo con i soli eventi di tastiera è un po' più complicato che farlo usando il codice. Utilizzeremo invece l'<strong>evento Step</strong> - che dovrete aggiungere subito a <span class="notranslate">object</span> - con le azioni o il codice seguenti per utilizzare i tasti freccia per muoversi:</p>
    <p class="dropspot"><img alt="Animation Of Instance Moving Towards Mouse" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_1_1.gif" /></p>
    <p class="code">if keyboard_check(vk_left)<br />
      {<br />
          x = x - 2;<br />
      }<br />
      else if keyboard_check(vk_right)<br />
      {<br />
          x = x + 2;<br />
      }<br />
      else if keyboard_check(vk_up)<br />
      {<br />
          y = y - 2;<br />
      }<br />
      else if keyboard_check(vk_down)<br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot">Utilizziamo una struttura &quot; <span class="inline">if... else if... else if...</span>&quot; per garantire che l'istanza si muova in una sola direzione alla volta, quindi l'istanza dovrebbe essere in grado di muoversi solo in alto, in basso, a sinistra o a destra, ma non in diagonale. Posizionate un'istanza di <span class="notranslate">object</span> in un sito <span class="notranslate">room</span> e premete il pulsante <strong>Play </strong> <img> per testarlo subito! Se tutto è andato bene, si dovrebbe avere qualcosa di simile a questo:</p>
    <p class="dropspot"><img alt="GML VisualTo Set The Instance Speed" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_2.png" /></p>
    <p class="dropspot">Possiamo modificare questo codice per convertire il movimento a 4 vie in movimento a 8 vie in modo semplice... è sufficiente rimuovere i comandi &quot; <span class="inline">else</span>&quot; dai blocchi di codice in modo che tutto appaia come questo:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">if keyboard_check(vk_left)<br />
      {<br />
          x = x - 2;<br />
      }<br />
      if keyboard_check(vk_right)<br />
      {<br />
          x = x + 2;<br />
      }<br />
      if keyboard_check(vk_up)<br />
      {<br />
          y = y - 2;<br />
      }<br />
      if keyboard_check(vk_down)<br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot">Ora, quando si preme il pulsante <strong>Play </strong> <img>, l'aspetto sarà simile a questo:</p>
    <p class="dropspot"><img alt="Animation Showing Instance Vibrating" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_1_2.gif" /></p>
    <p class="dropspot">Un'ultima cosa che vale la pena di notare per gli utenti che codificano con <span class="notranslate">GML</span>... Quando si usa <span class="notranslate">GML</span> Visual è possibile selezionare il tasto della tastiera che si desidera utilizzare da un elenco a discesa, ma con <span class="notranslate">GML</span> non è così semplice. Esiste un certo numero di <a href="../GameMaker_Language/GML_Reference/Game_Input/Keyboard_Input/Keyboard_Input.htm">costanti di tastiera</a> che si possono usare, come quelle per i tasti freccia mostrate nel codice precedente, ma <em>non esistono </em>costanti per i tasti alfanumerici. Questi sono gestiti in modo leggermente diverso e richiedono l'uso della funzione <a href="../GameMaker_Language/GML_Reference/Strings/ord.htm"><span class="inline">ord()</span></a>. Il codice seguente mostra come funzionerebbe utilizzando WASD al posto dei tasti freccia:</p>
    <p class="code">if keyboard_check(ord(&quot;A&quot;))<br />
      {<br />
          x = x - 2;<br />
      }<br />
      if keyboard_check(ord(&quot;D&quot;))<br />
      {<br />
          x = x + 2;<br />
      }<br />
      if keyboard_check(ord(&quot;W&quot;))<br />
      {<br />
          y = y - 2;<br />
      }<br />
      if keyboard_check(ord(&quot;S&quot;))<br />
      {<br />
          y = y + 2;<br />
      }</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down2" href="#">Movimento del gamepad</a></p>
  <div class="droptext" data-targetname="drop_down2">
    <p class="dropspot">Abbiamo parlato del movimento del mouse e della tastiera, quindi è arrivato il momento di parlare del movimento <strong>del gamepad </strong>. Non ci occuperemo del d-pad, che funziona come la tastiera (basta cambiare le funzioni della tastiera nell'esempio precedente in <a href="../GameMaker_Language/GML_Reference/Game_Input/GamePad_Input/gamepad_button_check.htm"><span class="inline">gamepad_button_check()</span></a> o <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Gamepad/If_Gamepad_Button_Down.htm">If Gamepad button Down</a>), quindi in questo esempio esamineremo l'uso dello stick analogico per il movimento.</p>
    <p class="dropspot">Per cominciare, dobbiamo rilevare il gamepad utilizzato. Ai gamepad viene assegnato un valore ID da 0 a 11, quindi utilizzeremo il comando &quot; <span class="inline">for</span>&quot; <span class="notranslate">loop</span> per rilevare l'ID di qualsiasi gamepad collegato e memorizzare questo valore ID in una variabile per un uso futuro. Poiché vogliamo impostare solo il primo gamepad collegato e non tutti, useremo il comando &quot; <span class="inline">break</span>&quot; dopo aver rilevato un gamepad, in modo da &quot;interrompere&quot; il comando <span class="notranslate">loop</span> (per esempio, se il primo gamepad collegato è l'ID 4, allora il comando <span class="notranslate">loop</span> verrà eseguito solo 5 volte, controllando i valori ID da 0 a 4 e poi interrompendo il comando <span class="notranslate">loop</span> quando viene incontrato il gamepad). Quindi, create (o aprite) un <span class="notranslate">object</span>, assegnategli un <span class="notranslate">sprite</span> e quindi aggiungete un <strong>evento Create</strong> con quanto segue:</p>
    <p class="dropspot"><img alt="GML VisualActions For The Step Event" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_1_3.png" /></p>
    <p class="code">gamepad_id = -1;<br />
      <br />
      for (var i = 0; i &lt; 12; i += 1;)<br />
      {<br />
          if gamepad_is_connected(i)<br />
          {<br />
              gamepad_id = i;<br />
              gamepad_set_axis_deadzone(gamepad_id, 0.2);<br />
      <br />
              break;<br />
          }<br />
      }
    </p>
    <p class="dropspot">Si noti che nel codice precedente è stato impostato il parametro <strong> <a class="glossterm" data-glossterm="zona morta" href="#">zona morta</a> </strong>per il gamepad. Questo perché gli stick analogici di gamepad di marche diverse hanno sensibilità diverse e a volte possono essere così sensibili che, se non si imposta una deadzone, possono causare movimenti indesiderati nei giochi. Quindi impostiamo la zona morta su un valore come 0,2 per dire a <span data-keyref="GameMaker Name">GameMaker</span> di ignorare qualsiasi valore di stick del gamepad inferiore a quel valore <a class="glossterm" data-glossterm="assoluto" href="#">assoluto</a>.</p>
    <p class="dropspot">Per aggiungere il movimento vero e proprio, avremo bisogno di un <strong>evento passo</strong>, quindi aggiungiamolo subito e diamogli il seguente <span class="notranslate">GML</span> Visual o GML:</p>
    <p class="dropspot"><img alt="GML VisualExample" class="center" src="../assets/Images/QS_Guide/QS_DnD_Example.png" /></p>
    <p class="code">if gamepad_id &gt; -1<br />
      {<br />
          var _h = gamepad_axis_value(gamepad_id, gp_axislh);<br />
          var _v = gamepad_axis_value(gamepad_id, gp_axislv);<br />
          x += _h * 4;<br />
          y += _v * 4;<br />
      }</p>
    <p class="dropspot">Qui stiamo controllando il movimento orizzontale o verticale dello stick <em>sinistro </em>. Le funzioni degli assi restituiscono un valore compreso tra -1 e 1, quindi per l'asse orizzontale -1 corrisponde a sinistra, 0 a non muoversi e 1 a destra, mentre per l'asse verticale -1 corrisponde a su, 0 a non muoversi e 1 a giù. Si noti inoltre che i valori sono <em>compresi tra </em>-1 e 1, quindi - ad esempio - l'asse orizzontale potrebbe restituire un valore di 0,5, il che significa che lo stick è a metà strada tra la posizione di &quot;riposo&quot; e la posizione completamente spinta verso destra. Per questo motivo, si moltiplica il valore per 4 (in realtà si può moltiplicare per qualsiasi valore, a seconda della velocità con cui si desidera che l'istanza si muova): ciò significa che la velocità dell'istanza varierà a seconda di quanto è stato effettuato il movimento sull'asse dello stick.</p>
    <p class="dropspot">Posizionare un'istanza di questo <span class="notranslate">object</span> in un sito <span class="notranslate">room</span> e premere il pulsante <strong>Play </strong>. <strong> <img></strong>quindi spostarsi utilizzando lo stick sinistro del gamepad collegato. Dovreste vedere qualcosa di simile a questo:</p>
    <p class="dropspot"><img alt="GML VisualStep Event Movement Actions" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_2_1.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down3" href="#">Movimento avanzato a 8 vie</a></p>
  <div class="droptext" data-targetname="drop_down3">
    <p class="dropspot">In questo ultimo esempio, rivedremo il nostro codice di movimento a 8 direzioni e affronteremo un problema che ha: il movimento in diagonale è in realtà più veloce di quello in alto/basso/sinistra/destra. Questo perché quando ci si muove in diagonale, ci si muove lungo l'ipotenusa di un triangolo rettangolo creato dai valori di movimento x/y:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="dropspot">Per rendere più chiaro ciò che sta accadendo, rimuoviamo tutto il testo e <span class="notranslate">sprites</span> e mostriamo semplicemente la stessa linea di movimento ruotata di 45° in modo che sia orizzontale:</p>
    <p class="dropspot"><img alt="Animation Showing 4-Way Keyboard Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_2_1.gif" /></p>
    <p class="dropspot">Come si può vedere, la differenza è piuttosto evidente e se l'istanza si sposta di più di 1 o 2 pixel per passo, diventa molto evidente che il movimento diagonale è <em>molto </em>più veloce! Come limitare questo fenomeno? Ci sono diversi modi per farlo, ma ci concentreremo solo su uno di essi, perché introduce un paio di funzioni e concetti che vi saranno utili in seguito nei vostri giochi.</p>
    <p class="dropspot">Per risolvere questo problema, dovremo memorizzare i valori di input dei tasti premuti indipendentemente in <a class="glossterm" data-glossterm="variabile" href="#">variabili</a>, per poi controllarli e muoverci in base alla combinazione di tasti che sono stati premuti. A tal fine, è necessario un <span class="notranslate">object</span> con un <span class="notranslate">sprite</span> assegnato e un <strong>evento Step</strong> con le seguenti azioni o codice:</p>
    <p class="dropspot"><img alt="GML VisualStep Event Movement Actions" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_2_2.png" /></p>
    <p class="note"><span class="note">NOTA</span> Abbiamo suddiviso le azioni visive su due colonne per facilitarne la visualizzazione, ma nell'editor visuale saranno posizionate consecutivamente.</p>
    <p class="code">var _left = keyboard_check(vk_left);<br />
      var _right = keyboard_check(vk_right);<br />
      var _up = keyboard_check(vk_up);<br />
      var _down = keyboard_check(vk_down);<br />
      var _hspd = _right - _left;<br />
      var _vspd = _down - _up;</p>
    <p class="dropspot">Dovremo aggiungere altro codice per muoverci effettivamente, ma prima di farlo, spieghiamo un po' come funziona. Vogliamo convertire sinistra/destra/su/giù in valori equivalenti di velocità orizzontale e verticale, quindi per farlo otteniamo il valore di ciascun tasto e poi facciamo alcuni calcoli di base per ottenere i valori di velocità. Questo funziona perché se un tasto viene premuto, l'azione o la funzione di controllo restituirà &quot;1&quot;, mentre se <em>non </em>viene premuto, la funzione restituirà 0. Quindi, se, ad esempio, il tasto destro viene premuto, la funzione restituirà &quot;1&quot;. Quindi, se, per esempio, viene premuto il tasto destro, si ha &quot;1 - 0 = 1&quot; per &quot; <span class="inline">_hspd</span>&quot;, mentre se viene premuto il tasto sinistro si ha &quot;0 - 1 = -1&quot; per &quot; <span class="inline">_hspd</span>&quot; (e se vengono premuti entrambi, allora è &quot;1 - 1 = 0&quot;, quindi l'istanza non si muove). Ricordate che in <span data-keyref="GameMaker Name">GameMaker</span> <span class="notranslate">room</span>, per spostarsi a destra si aggiunge alla posizione di <span class="inline">x </span>e per spostarsi a sinistra si sottrae, quindi questo codice ci darà un valore positivo o negativo che possiamo aggiungere o sottrarre per spostarci orizzontalmente o verticalmente a seconda dell'input della tastiera.</p>
    <p class="dropspot">Ora possiamo aggiungere il codice che sposta effettivamente l'istanza, quindi, sempre nell'<strong>evento Step</strong> e dopo il codice precedente, aggiungiamo questo:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">if (_hspd != 0 || _vspd != 0)<br />
      {<br />
          var _spd = 4;<br />
          var _dir = point_direction(0, 0, _hspd, _vspd);<br />
          var _xadd = lengthdir_x(_spd, _dir);<br />
          var _yadd = lengthdir_y(_spd, _dir);<br />
          x = x + _xadd;<br />
          y = y + _yadd;<br />
      }</p>
    <p class="dropspot">Il codice sopra riportato controlla innanzitutto se una delle due <a class="glossterm" data-glossterm="espressione" href="#">espressioni</a>è vera, cioè se le variabili velocità orizzontale o verticale non sono 0. Si noti che il controllo &quot; <span class="inline">if</span>&quot; <span class="notranslate">GML</span> utilizza il simbolo &quot; <span class="inline">||</span>&quot;. Questo significa &quot; <span class="inline">or</span>&quot; in programmazione, quindi - in parole povere - si sta controllando</p>
    <p class="code">if the variable _hspd does not equal zero<br />
      <strong>or</strong><br />
      if the variable _vspd does not equal zero
    </p>
    <p class="dropspot">In questo modo, è possibile <span class="notranslate">string</span> riunire più espressioni in un controllo &quot; <span class="inline">if</span>&quot; e ci sono diversi modi in cui queste espressioni possono essere valutate (per ulteriori informazioni, vedere la sezione <strong>Espressioni</strong> <a href="../GameMaker_Language/GML_Overview/Expressions_And_Operators.htm">qui</a>).</p>
    <p class="dropspot">La prossima sezione di codice memorizza un valore per la velocità di movimento effettiva in una variabile e poi ottiene una direzione usando i valori <span class="inline">_hspd </span>e <span class="inline">_vspd </span>, che possono essere -1, 0, o 1. La funzione direzione controlla da (0, 0), poiché non stiamo usando le coordinate <span class="notranslate">room</span>, ma vogliamo che valuti una direzione da 0° a 360° in base ai valori delle variabili. Il diagramma seguente illustra meglio ciò che sta accadendo rispetto al tentativo di spiegarlo a parole:</p>
    <p class="dropspot"><img alt="Animation Showing 8-Way Keyboard Movement" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_2_2.gif" /></p>
    <p class="note"><span class="note">NOTA</span> La direzione in <span data-keyref="GameMaker Name">GameMaker</span> è calcolata <strong>in senso antiorario</strong>, quindi 0° e 360° sono a destra, 90° è in alto, 180° è a destra e 270° è in basso.</p>
    <p class="dropspot">Infine, utilizziamo i parametri <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/lengthdir_x.htm"><span class="inline">lengthdir_x()</span></a> e <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/lengthdir_y.htm"><span class="inline">lengthdir_y()</span></a> per spostare effettivamente la variabile. Si tratta di funzioni <strong> <a class="glossterm" data-glossterm="vettore" href="#">vettore</a>  </strong>che prendono una lunghezza (distanza) e una direzione e poi calcolano la nuova posizione sull'asse dato in base a questi valori (si vedano le descrizioni delle funzioni per una spiegazione più approfondita).</p>
    <p class="dropspot">Sono molte cose da assimilare in una volta sola, e non preoccupatevi se non riuscite a capire tutto! Lo capirete col tempo! Ora non resta che aggiungere un'istanza di questo <span class="notranslate">object</span> a un sito <span class="notranslate">room</span> e premere il pulsante <strong>Play </strong>. <strong> <img></strong>e si dovrebbe ottenere un movimento fluido come la seta in 8 direzioni, senza i problemi legati al movimento in diagonale:</p>
    <p class="dropspot"><img alt="Getting Gamepad ID Using DnD" class="center" src="../assets/Images/QS_Guide/QS_MovementExample_DnD_3_1.png" /></p>
  </div>
  <p> </p>
  <p>Con questi esempi e con i precedenti per il disegno, speriamo che abbiate capito abbastanza per iniziare a realizzare i vostri progetti! L'ultima pagina di questa Guida rapida contiene un riepilogo di alcune delle cose apprese e i link a ulteriori materiali didattici.</p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Indietro: <a href="../Content.htm">Indice</a></div>
        <div style="float:right">Avanti: <a href="Summary.htm">Sintesi</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Tutti i diritti riservati</span></h5>
  </div>
  <!-- KEYWORDS
Movement
Controls
Movement and Controls
Movement Examples
Controls Examples
-->
  <!-- TAGS
qs_movement_controls
-->
</body>
</html>