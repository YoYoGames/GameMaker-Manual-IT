<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Disegno</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../assets/css/default.css" type="text/css" />
  <script src="../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Some basic code to show people how things are drawn." />
  <meta name="rh-index-keywords" content="Quick Start - Drawing" />
  <meta name="search-keywords" content="drawing,draw event,GUI layer" />
  <meta name="robots" content="NOODP" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Disegno</h1>
  <p>Questa sezione (e quella successiva su <a href="Movement_And_Controls.htm">Movimento e controlli</a>) ha lo scopo di fornire esempi pratici di <span class="notranslate">GML</span> o <span class="notranslate">GML</span> Visual, per consentirvi di iniziare il più rapidamente possibile a realizzare i vostri primi progetti di gioco. Non spiegheremo le cose in modo troppo approfondito, perché vogliamo che iniziate a creare il più rapidamente possibile, quindi vi invitiamo a esplorare i link man mano che procedete e a usare la funzione &quot;ricerca&quot; del manuale per cercare informazioni aggiuntive su qualsiasi cosa non vi sia chiara.</p>
  <p>In questa sezione ci concentreremo sul semplice disegno di informazioni sullo schermo, sia come testo che come immagini, e spiegheremo anche qualcosa di più sui diversi <strong>eventi di disegno</strong>, in particolare l'evento <strong>Draw</strong> principale e l'evento <strong>Draw GUI </strong>(si noti che in alcuni esempi sarà necessario aggiungere altri eventi, ma li spiegheremo man mano).</p>
  <p><img alt="The Draw Events" class="center" src="../assets/Images/QS_Guide/QS_DrawEvents.png" /></p>
  <p>Prima di andare avanti, è consigliabile creare un nuovo progetto ( <span class="notranslate">GML</span> o <span class="notranslate">GML</span> Visual) dalla <a href="../Introduction/The_Start_Page.htm">pagina iniziale</a> e aggiungere (o creare) alcuni <span class="notranslate">sprites</span> e uno o due <span class="notranslate">object</span>, poiché vi forniremo del codice da testare con questi. Anche un quadrato bianco funzionerà per ora come <span class="notranslate">sprite</span> per il nostro <span class="notranslate">object</span>!</p>
  <p>Ora, come accennato nella sezione <a href="Objects_And_Instances.htm">Oggetti e istanze</a>, se non si aggiunge un evento di disegno a <span class="notranslate">object</span>, <span data-keyref="GameMaker Name">GameMaker</span> disegnerà di default, il che significa che se <span class="notranslate">object</span> ha un <span class="notranslate">sprite</span> assegnato ad esso, questo <span class="notranslate">sprite</span> verrà disegnato, completo di tutte le trasformazioni che sono state aggiunte. Che cosa si intende per trasformazioni? <span class="notranslate">object</span> Ogni <span class="notranslate">object</span> ha un certo numero di <a class="glossterm" data-glossterm="variabile" href="#">variabili</a> incorporate che controllano il modo in cui un'istanza di <span class="notranslate">sprite</span> disegna il suo <span class="notranslate">sprite</span> quando viene disegnato per default.</p>
  <p class="note"><strong>NOTA</strong>: Un elenco di tutte le variabili integrate che possono essere utilizzate per trasformare l'istanza <span class="notranslate">sprites</span> è disponibile <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/Sprite_Instance_Variables.htm">qui</a>. <span class="notranslate">GML</span> Gli utenti di Visual hanno alcune azioni dedicate che agiscono su queste variabili, che si possono trovare <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Drawing/Drawing_Actions.htm">qui</a>, e si possono anche usare le variabili stesse con le azioni <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Get_Instance_Variable.htm">Get Instance Variable</a> e <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Set_Instance_Variable.htm">Set Instance Variable</a>.</p>
  <p>Vediamo alcuni esempi:</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down" href="#">Modifica dell'alfa (trasparenza)</a></p>
  <div class="droptext" data-targetname="drop_down">
    <p class="dropspot">Il valore <strong>alfa </strong>controlla la trasparenza di ciò che viene disegnato e in <span data-keyref="GameMaker Name">GameMaker</span> è possibile utilizzare la variabile incorporata <span class="inline">image_alpha</span> per modificare la trasparenza dell'oggetto <span class="notranslate">sprite</span> assegnato. Per vedere come funziona, aprite (o create) un <span class="notranslate">object</span>, assegnategli un <span class="notranslate">sprite</span> e poi date a <span class="notranslate">object</span> un <strong>evento Create</strong>. Nell'evento Create, è sufficiente aggiungere il seguente <span class="notranslate">GML</span> Visual o GML:</p>
    <p class="dropspot"><img alt="GML VisualDraw Example For Transparency" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_1.png" /></p>
    <p class="code">var _val = random(1);
      <br />
      image_alpha = _val;
    </p>
    <p class="dropspot">L'alfa dell'immagine è calcolato come un valore da 0 a 1, dove 0 è completamente trasparente e 1 completamente opaco (per impostazione predefinita è impostato su 1). Quindi, in questo esempio, tutto ciò che stiamo facendo è impostare l'alfa dell'immagine su un valore decimale casuale da 0 a 1. Posizionate alcune istanze di questo <span class="notranslate">object</span> in un <span class="notranslate">room</span>, quindi fate clic sul pulsante <strong>Play </strong> <img> nella parte superiore del <span class="notranslate">IDE</span>.</p>
    <p class="dropspot">Si dovrebbe notare che ogni istanza di <span class="notranslate">object</span> disegna il suo <span class="notranslate">sprite</span> con una trasparenza diversa, ad esempio:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down1" href="#">Modifica della miscela di colori (tintura)</a></p>
  <div class="droptext" data-targetname="drop_down1">
    <p class="dropspot">Quando il vostro <span class="notranslate">object</span> disegna per default un <span class="notranslate">sprite</span>, questo <span class="notranslate">sprite</span> viene in realtà disegnato <strong>sfumato </strong>(o <strong>colorato</strong>) con un colore, il cui valore è memorizzato nella variabile incorporata <span class="inline">image_blend</span>. Per impostazione predefinita, questo colore è il bianco, il che significa essenzialmente che non viene aggiunto alcun colore a <span class="notranslate">sprite</span> quando viene visualizzato sullo schermo. Tuttavia, è possibile utilizzare altri colori per ottenere effetti speciali, ad esempio utilizzare il rosso per mostrare che l'istanza ha ricevuto dei danni.</p>
    <p class="dropspot">In questo esempio, si intende sfumare colori diversi con <span class="notranslate">sprite</span> mentre si tiene premuto un tasto, quindi è necessario aprire (o creare) un <span class="notranslate">object</span>, assegnargli un <span class="notranslate">sprite</span>, quindi assegnare a <span class="notranslate">object</span> un <strong>evento Tasto giù &lt;Spazio&gt;</strong>.</p>
    <p class="dropspot"><img alt="Example Of Sprites Drawn With Different Alpha Values" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_1.png" /></p>
    <p class="dropspot">In questo evento tasto giù, aggiungere il seguente <span class="notranslate">GML</span> Visual o GML:</p>
    <p class="dropspot"><img alt="Add Key Down Event" class="center" src="../assets/Images/QS_Guide/QS_Add_SpaceKeyPressEvent.png" /></p>
    <p class="code">var _col = choose(c_red, c_green, c_blue, c_yellow, c_fuchsia, c_orange);
      <br />
      image_blend = _col;
    </p>
    <p class="dropspot">Posizionate alcune istanze di questo <span class="notranslate">object</span> in un <span class="notranslate">room</span>, quindi fate clic sul pulsante Play <img> nella parte superiore del <span class="notranslate">IDE</span> e provate a tenere premuto e a rilasciare il tasto <em>Spazio </em>. Dovreste notare che ogni istanza cambierà rapidamente colore mentre il tasto è tenuto premuto e smetterà di cambiare quando viene rilasciato:</p>
    <p class="dropspot"><img alt="GML VisualExample Using Key Down Event" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_2.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down2" href="#">Cambiamento di scala</a></p>
  <div class="droptext" data-targetname="drop_down2">
    <p class="dropspot">Un'altra delle proprietà che possiamo modificare per il nostro <span class="notranslate">sprite</span> è il valore di <strong>scala </strong>, che ci permette di disegnarlo più grande o più piccolo quando vogliamo. La scala è calcolata in modo indipendente lungo gli assi X e Y da due variabili distinte, la variabile <span class="inline">image_xscale</span> e la variabile <span class="inline">image_yscale</span>. Per impostazione predefinita sono impostate a 1 e agiscono come <strong>moltiplicatori</strong>, quindi un valore di 0,5 equivale a metà scala e un valore di 2 equivale al doppio della scala.</p>
    <p class="note"><strong>IMPORTANTE! </strong>Se si modifica la scala assegnata a <span class="notranslate">sprite</span> utilizzando queste variabili <strong>, si modificherà anche la dimensione del rettangolo di selezione</strong>, il che significa che anche l'area di rilevamento delle collisioni di <span class="notranslate">sprite</span> si ridimensionerà.</p>
    <p class="dropspot">In questo esempio, utilizzeremo alcuni semplici calcoli per far sì che un'istanza faccia scalare il <span class="notranslate">sprite</span> verso l'alto e verso il basso in un <span class="notranslate">loop</span>. Per iniziare, aprite (o create) un <span class="notranslate">object</span>, assegnategli un <span class="notranslate">sprite</span>, quindi date al <span class="notranslate">object</span> un <strong>evento Create</strong>. In questo evento aggiungere quanto segue:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">timer = 0;</p>
    <p class="dropspot">Ora aggiungete un <strong>evento passo</strong> a <span class="notranslate">object</span> con questo:</p>
    <p class="dropspot"><img alt="Example Showing Colour Blending" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_2.png" /></p>
    <p class="code">timer = timer + 1;
      <br />
      var _val = dsin(timer);
      <br />
      image_xscale = 1 + _val;
      <br />
      image_yscale = 1 + _val;
    </p>
    <p class="dropspot">In questo caso, utilizziamo la funzione maths <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/dsin.htm"><span class="inline">dsin()</span></a> per generare un valore compreso tra -1 e 1 usando la variabile timer e applicandolo poi alle variabili di scala. Dopo aver inserito alcune istanze in un sito <span class="notranslate">room</span> e aver premuto il pulsante <strong>Riproduci </strong> <img>, si dovrebbe vedere come le istanze scalano su e giù da una scala di 0 a una scala di 2 e poi di nuovo indietro.</p>
    <p class="dropspot"><img alt="GML VisualSet Variable Example" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_3_1.png" /></p>
    <p class="dropspot">Un'ultima cosa... cambiate la sezione &quot; <span class="inline">image_yscale</span>&quot; in &quot; <span class="inline">1 - _val</span>&quot; e vedete cosa succede!</p>
    <p class="dropspot"> </p>
  </div>
  <p> </p>
  <p>Gli esempi precedenti illustrano solo alcuni dei molti modi in cui è possibile manipolare <span class="notranslate">object</span> <span class="notranslate">sprite</span> quando <span data-keyref="GameMaker Name">GameMaker</span> disegna in modo predefinito, ma se si desidera disegnare più di una cosa per <span class="notranslate">object</span>? In questi casi è necessario utilizzare l'<strong>evento Draw</strong> per dire esplicitamente a <span data-keyref="GameMaker Name">GameMaker</span> cosa disegnare, cosa che faremo negli esempi seguenti.</p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down3" href="#">Disegnare due (o più) <span class="notranslate">Sprites</span> insieme</a></p>
  <div class="droptext" data-targetname="drop_down3">
    <p class="dropspot">Per questo esempio, sono necessari due <span class="notranslate">sprites</span> e un <span class="notranslate">object</span>. Chiamate <span class="notranslate">sprites</span> &quot; <span class="inline">spr_One</span>&quot; e &quot; <span class="inline">spr_Two</span>&quot;, quindi impostate l'origine di &quot; <span class="inline">spr_One</span>&quot; al centro e quella di &quot; <span class="inline">spr_Two</span>&quot; al centro-sinistra:</p>
    <p class="dropspot"><img>Assegnare il primo <span class="notranslate">sprite</span> (&quot; <span class="inline">spr_One</span>&quot; con l'origine centrale) al <span class="notranslate">object</span> creato e poi aggiungere un <strong>evento Create</strong>. Nell'evento Create aggiungere il seguente <span class="notranslate">GML</span> Visual o GML:</p>
    <p class="dropspot"><img alt="GML VisualActions To Change Sprite Scale" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_3_2.png" /></p>
    <p class="code">draw_angle = 0;</p>
    <p class="dropspot">Utilizzeremo questa variabile per ruotare &quot; <span class="inline">spr_Two</span>&quot; nel tempo e disegnarlo sovrapposto al <span class="notranslate">sprite</span> assegnato al <span class="notranslate">object</span> (&quot; <span class="inline">spr_One</span>&quot;). Per fare ciò, dobbiamo aggiungere un <strong>evento Draw </strong>a <span class="notranslate">object</span>. In questo modo, diciamo a <span data-keyref="GameMaker Name">GameMaker</span> che vogliamo occuparci di ciò che l'istanza disegna, il che significa che il nostro codice includerà una chiamata alla funzione <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_self.htm"><span class="inline">draw_self()</span></a> funzione o <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Drawing/Draw_Self.htm"><strong>Disegnare se stessi</strong></a> azione. Questa azione replica semplicemente ciò che fa <span class="notranslate">object</span> quando non è presente alcun Evento di disegno e disegna per default l'oggetto <span class="notranslate">sprite</span>. Disegneremo quindi il secondo <span class="notranslate">sprite</span> che vogliamo utilizzare come sovrapposizione di <span class="notranslate">sprite</span> che sta ruotando. La vista <span class="notranslate">GML</span> e <span class="notranslate">GML</span> si presentano così:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">draw_self();
      <br />
      draw_angle = draw_angle + 0.5;
      <br />
      draw_sprite_ext(spr_Two, 0, x, y, 1, 1, draw_angle, c_red, 1);
    </p>
    <p class="dropspot">Aggiungete un certo numero di istanze di <span class="notranslate">object</span> nell'editor <span class="notranslate">room</span> e poi premete il pulsante <strong>Play </strong> <img> nella parte superiore dell'<a class="glossterm" data-glossterm="IDE" href="#">IDE</a>. Se tutto è andato correttamente, dovreste vedere qualcosa di simile a questo:</p>
    <p class="dropspot"><img class="center" src="../assets/Images/QS_Guide/QS_DrawExample_3.gif" title="Animation Showing Sprite Scaling" /></p>
    <p class="dropspot">Prima di lasciare questo esempio, modifichiamolo un po' e invece di far ruotare semplicemente &quot; <span class="inline">spr_Two</span>&quot;, facciamo in modo che punti verso la posizione del mouse. A tale scopo, dobbiamo modificare l'evento Draw <span class="notranslate">GML</span> Visual o <span class="notranslate">GML</span> in questo modo:</p>
    <p class="dropspot"><img alt="Show Origins For Sprites" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_1.png" /></p>
    <p class="code">draw_self();
      <br />
      draw_angle = point_direction(x, y, mouse_x, mouse_y);
      <br />
      draw_sprite_ext(spr_Two, 0, x, y, 1, 1, draw_angle, c_red, 1);
    </p>
    <p class="dropspot">Eseguite nuovamente il progetto e questa volta vedrete qualcosa di molto diverso!</p>
    <p class="dropspot"><img>Il <span class="notranslate">sprite</span> ora punta verso il mouse, indipendentemente da dove lo si sposta! Come potete vedere, la stratificazione di <span class="notranslate">sprites</span> è un ottimo modo per aggiungere dettagli a <span class="notranslate">object</span> o per far muovere qualcosa indipendentemente dalla &quot;base&quot; <span class="notranslate">sprite</span> assegnata a <span class="notranslate">object</span>, ed è uno strumento potente che probabilmente userete spesso nei vostri progetti.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down4" href="#">Disegnare cose diverse dagli sprite</a></p>
  <div class="droptext" data-targetname="drop_down4">
    <p class="dropspot">Nell'evento Draw si possono disegnare anche cose diverse da <span class="notranslate">sprites</span>, come testo o forme. In questo esempio, useremo la funzione <span class="notranslate">GML</span> Visual o <span class="notranslate">GML</span> <span class="inline">draw_self()</span> per disegnare <span class="notranslate">object</span> <span class="notranslate">sprite</span>, ma disegneremo anche altre cose, a partire da un <strong>testo</strong>. Per questo esempio, sono necessari un <span class="notranslate">sprite</span> e un <span class="notranslate">object</span> (a cui è assegnato il <span class="notranslate">sprite</span> ). In <span class="notranslate">object</span>, per prima cosa aggiungete un <strong>evento Create</strong> con questo <span class="notranslate">GML</span> Visual o GML:</p>
    <p class="dropspot"><img alt="Set Draw Angle Variable In DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_1.png" /></p>
    <p class="code">name = choose(&quot;Fred&quot;, &quot;Jonas&quot;, &quot;Sharon&quot;, &quot;Kate&quot;, &quot;Frank&quot;, &quot;John&quot;, &quot;Monica&quot;, &quot;Amanda&quot;);
      <br />
      number = irandom(100);
    </p>
    <p class="dropspot">Tutto ciò serve a dire a <span data-keyref="GameMaker Name">GameMaker</span> di scegliere uno dei nomi elencati e di assegnarlo a una variabile, oltre a generare un numero casuale da 0 a 100 per ogni istanza di <span class="notranslate">object</span>. Vogliamo disegnare questi valori sullo schermo e per questo è necessario aggiungere un <strong>evento Draw</strong> e in esso aggiungere il seguente <span class="notranslate">GML</span> Visual o GML:</p>
    <p class="dropspot"><img alt="Draw Two Sprites With DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_2.png" /></p>
    <p class="code">draw_self();
      <br />
      draw_set_halign(fa_center);
      <br />
      draw_text(x, y + 32, &quot;My name is &quot; + name);
      <br />
      draw_text(x, y + 48, &quot;My number is &quot; + string(number));
    </p>
    <p class="dropspot">Si noterà che nel codice sopra riportato si utilizza la funzione <a href="../GameMaker_Language/GML_Reference/Strings/string.htm"><span class="inline">string()</span></a> o la funzione <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Data_Types/Number_To_String.htm"><strong>Da numero a stringa</strong></a> sulla variabile &quot;numero&quot; che vogliamo disegnare. Questo perché tutto il testo deve essere composto da <em>caratteri</em>, non da valori, e quindi dobbiamo usare questa funzione/azione per convertire il valore del numero in quei caratteri che vogliamo disegnare. In questo caso, prendiamo il numero casuale che abbiamo generato e lo trasformiamo in una &quot;stringa&quot; di caratteri da disegnare. Notate anche che abbiamo impostato l'<strong>allineamento</strong> del testo. Questo indica semplicemente a <span data-keyref="GameMaker Name">GameMaker</span> dove iniziare a disegnare il testo rispetto alla posizione data, e in questo caso vogliamo che il testo sia centrato lungo l'asse delle ascisse.</p>
    <p class="dropspot">Aggiungete un certo numero di istanze di <span class="notranslate">object</span> nell'editor <span class="notranslate">room</span> e poi premete il pulsante Play <img> nella parte superiore di <span class="notranslate">IDE</span>. Dovreste vedere qualcosa di simile a questo:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="dropspot">In tutti gli esempi fatti finora, abbiamo disegnato il <span class="notranslate">sprite</span> assegnato all'istanza, ma non è sempre così. È <strong>possibile disegnare qualsiasi cosa si voglia</strong> nell'evento draw, indipendentemente dal <span class="notranslate">sprite</span> assegnato. Per illustrare questo punto, modificheremo il codice attuale eliminando la chiamata a <span class="inline">draw_self()</span> e sostituendola con una funzione che disegna un'ellisse colorata, come questa:</p>
    <p class="dropspot"><img alt="Animation Drawing Two Sprites Together" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_2.gif" /></p>
    <p class="code">draw_ellipse_colour(x - 50, y - 32, x + 50, y + 32, c_fuchsia, c_lime, false);
      <br />
      draw_set_halign(fa_center);
      <br />
      draw_text(x, y + 32, &quot;My name is &quot; + name);
      <br />
      draw_text(x, y + 48, &quot;My number is &quot; + string(number));
    </p>
    <p class="dropspot">Eseguite di nuovo il progetto e dovreste vedere questo:</p>
    <p class="dropspot"><img alt="Edited Draw Code For Drawing Two Sprites With DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_3.png" /></p>
    <p class="dropspot">Una cosa importante da notare a questo proposito è che, anche se non si disegna il <span class="notranslate">sprite</span> assegnato, esso verrà <strong>comunque utilizzato per il rilevamento delle collisioni</strong>. Quindi, mentre si disegna una cosa, le collisioni saranno comunque calcolate in base al <span class="notranslate">sprite</span> assegnato, come se fosse posizionato nel <span class="notranslate">room</span> insieme all'istanza, anche se non è visibile. Questo è molto utile, perché permette di disegnare diversi <span class="notranslate">sprites</span>, ma di mantenere un'unica <strong>maschera di collisione</strong> basata sul <span class="notranslate">sprite</span> assegnato. Si noti anche che si possono ancora applicare le diverse trasformazioni, come la scala X/Y, e le collisioni si baseranno sulle dimensioni modificate, anche se non viene disegnato nulla che lo dimostri.</p>
  </div>
  <p> </p>
  <p> </p>
  <h1>Il livello GUI</h1>
  <p>All'inizio della pagina abbiamo detto che avremmo parlato dell'<strong>evento Draw GUI</strong> e dell'evento Draw. L'evento Draw GUI agisce su una cosa chiamata <strong> <a class="glossterm" data-glossterm="INTERFACCIA GRAFICA" href="#">GUI</a></strong> Layer, che è uno speciale livello di disegno di larghezza e altezza fisse che viene disegnato sopra le istanze di <span class="notranslate">room</span>. Il bello del GUI Layer è che non si <em> muove con la telecamera di <span class="notranslate">room</span> </em>, quindi è il luogo ideale per aggiungere elementi statici della GUI, come punteggi, barre di salute e altre informazioni che il gioco deve comunicare all'utente. Per ulteriori informazioni sul livello GUI, consultare la sezione <a href="../The_Asset_Editors/Object_Properties/Draw_Events.htm">Eventi di disegno</a> del manuale.</p>
  <p class="note"><strong>NOTA</strong>: <span class="notranslate">Rooms</span> può essere più grande della dimensione dello schermo, quindi è possibile avere livelli di grandi dimensioni in cui il giocatore può muoversi. Ciò significa che nell'editor di <span class="notranslate">Room</span> (o nel codice) è necessario definire una <strong>telecamera </strong>che segua l'azione del gioco. In pratica, si tratta di un modo per impostare un'area fissa dello schermo per visualizzare parti diverse del sito <span class="notranslate">room</span> in base, ad esempio, alla posizione del giocatore nel sito <span class="notranslate">room</span>, ed è utilizzato in molti giochi. Si pensi al modo in cui la visuale segue sempre il personaggio principale in giochi classici come Mario o Zelda. Questo viene fatto con le telecamere. Per ulteriori informazioni, consultare la sezione <a href="../The_Asset_Editors/Room_Properties/Room_Properties.htm">Proprietà della stanza</a> nella sezione Editor di <span class="notranslate">Room</span> del manuale.</p>
  <p>Gli esempi che seguono utilizzeranno tutti l'evento <strong>Draw GUI</strong>, quindi sarà necessario creare un <span class="notranslate">object</span> e aggiungervi questo evento. Si noti che a <span class="notranslate">object</span> non è necessario assegnare un <span class="notranslate">sprite</span>, in quanto non si vuole disegnare nulla di default e non è necessario che rilevi le collisioni. <span class="notranslate">Objects</span> come questo, che sono progettati solo per disegnare cose o controllare alcuni aspetti del gioco, sono spesso chiamati <strong>oggetti controller</strong>. Notate anche che useremo lo stesso <span class="notranslate">object</span> per tutti gli esempi, quindi vi consigliamo di esaminarli uno dopo l'altro (anche se non è strettamente necessario).</p>
  <p><img> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down5" href="#">Testo del disegno</a></p>
  <div class="droptext" data-targetname="drop_down5">
    <p class="dropspot">Quando si disegna sul livello GUI, l'angolo in alto a sinistra è la posizione di origine, mentre a destra c'è +X e in basso c'è +Y. Questo rende molto semplice il posizionamento di testo e grafica, come si vedrà in questo esempio. Tutto ciò che faremo qui è disegnare un valore che rappresenta il punteggio del giocatore, quindi nel nostro <span class="notranslate">object</span> dovremo aggiungere un <strong>evento Create </strong>per inizializzare una variabile che contenga questo valore, come questo:</p>
    <p class="dropspot"><img alt="Animation Drawing Two Sprites Pointing At Mouse" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_3.gif" /></p>
    <p class="code">player_score = 0;</p>
    <p class="dropspot">Aggiungiamo anche un <strong>evento Keyboard Down &lt;Space&gt;</strong> a <span class="notranslate">object</span>, poiché lo useremo per incrementare il punteggio ogni volta che si preme il tasto Spazio.</p>
    <p class="dropspot"><img alt="Setting Variables Using DnD" class="center" height="506" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_1_1.png" width="317" /></p>
    <p class="dropspot">In questo caso, aggiungere quanto segue:</p>
    <p class="dropspot"><img alt="Drawing Text Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_1.png" /></p>
    <p class="code">var _val = irandom(100);
      <br />
      player_score = player_score + _val;
    </p>
    <p class="dropspot">Infine, disegniamo il valore del punteggio nell'evento Draw GUI, in questo modo:</p>
    <p class="dropspot">In questo caso, aggiungere quanto segue:</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">draw_set_halign(fa_left);
      <br />
      draw_set_colour(c_yellow);
      <br />
      draw_text(32, 32, &quot;SCORE:&quot;);
      <br />
      draw_set_colour(c_white);
      <br />
      var _str = string(player_score);
      <br />
      draw_text_transformed(32, 48, _str, 2, 2, 0);
    </p>
    <p class="dropspot">Si noterà che abbiamo usato valori <a class="glossterm" data-glossterm="codificato" href="#">fissi</a> per la posizione x/y del testo da disegnare, poiché non abbiamo bisogno che sia relativo a nessuna istanza, dato che stiamo disegnando sul livello della GUI. Abbiamo anche usato la funzione &quot;set colour&quot; per cambiare il colore del testo e la funzione &quot;transformed&quot; per ingrandire il valore effettivo del punteggio, il che illustra come si possono personalizzare gli elementi di testo nei propri giochi.</p>
    <p class="dropspot">Aggiungete ora una singola istanza di questo <span class="notranslate">object</span> al vostro <span class="notranslate">room</span> e poi premete il tasto <strong>Play </strong> <img>. Quando il gioco viene avviato, premete e rilasciate il tasto <span class="inline">&lt;Space&gt;</span> e vedrete il valore del punteggio aumentare.</p>
    <p class="dropspot"><img alt="Sprites Being Drawn Along With Text" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_5_1.png" /></p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down6" href="#">Disegnare gli sprite</a></p>
  <div class="droptext" data-targetname="drop_down6">
    <p class="dropspot">In questo esempio, useremo il livello GUI per disegnare alcuni <span class="notranslate">sprites</span>. L'uso più ovvio è quello di disegnare le vite dei giocatori, quindi andiamo avanti e facciamo proprio questo! Per questo esempio è necessario un <span class="notranslate">sprite</span> - che dovrebbe essere di circa 64x64 pixel - ma non dovrebbe essere assegnato al <span class="notranslate">object</span>, poiché lo disegneremo noi stessi.</p>
    <p class="dropspot">Per cominciare, dobbiamo aggiungere alcune nuove variabili a <span class="notranslate">object</span> nell'<strong>evento Create</strong> (se avete fatto l'esempio precedente, aggiungete le seguenti sotto quelle già presenti):</p>
    <p class="dropspot"><img alt="Drawing Shapes Along With Text Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_2.png" /></p>
    <p class="code">player_lives = 3;
      <br />
      gui_w = display_get_gui_width();
    </p>
    <p class="dropspot">In questo codice inizializziamo una variabile per le vite del giocatore, ma creiamo anche una variabile per contenere la larghezza del livello della GUI, in modo da poter posizionare correttamente le cose rispetto alla destra dello schermo. Potremmo semplicemente codificare un valore nel codice e usarlo, ma ciò significherebbe che se in seguito si modificano le dimensioni di <span class="notranslate">room</span> o si aggiungono telecamere ecc..., bisognerà passare attraverso il codice e modificare il valore ovunque. L'uso della funzione <a href="../GameMaker_Language/GML_Reference/Cameras_And_Display/display_get_gui_width.htm"><span class="inline">display_get_gui_width()</span></a> significa che non dobbiamo preoccuparci di eventuali modifiche future, perché il codice si adatterà automaticamente alle dimensioni del livello della GUI.</p>
    <p class="dropspot">Poi vogliamo aggiungere un <strong>evento Keyboard Pressed &lt;Enter&gt;</strong> a <span class="notranslate">object</span>, che useremo per cambiare il numero di vite ogni volta che viene premuto il tasto Invio:</p>
    <p class="dropspot"><img alt="Example Of Drawing Shapes And Text Together" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_5_2.png" /></p>
    <p class="dropspot">In questo caso, aggiungere quanto segue:</p>
    <p class="dropspot"><img alt="Draw GUI Event In An Object" class="center" src="../assets/Images/QS_Guide/QS_DrawGUIObject.png" /></p>
    <p class="code">player_lives = player_lives - 1;
      <br />
      <br />
      if player_lives &lt; 0
      <br />
      {
      <br />
      player_lives = 3;
      <br />
      }
    </p>
    <p class="dropspot">Infine, dobbiamo disegnare <span class="notranslate">sprites</span> sul display. Per questo useremo un &quot; <span class="inline">for</span>&quot; <span class="notranslate">loop</span> (informazioni sull'uso di <span class="notranslate">GML</span> <a href="../GameMaker_Language/GML_Overview/Language_Features/for.htm">qui</a> e per <span class="notranslate">GML</span> Visual <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Loops/For.htm">qui</a>), insieme alla variabile GUI width per posizionare tutto nell'angolo in alto a destra dello schermo. Aggiungete quindi questo elemento all'evento Draw Gui (dopo qualsiasi altra azione che potrebbe avere negli esempi precedenti):</p>
    <p class="dropspot"><img alt="Defining A Variable Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_1.png" /></p>
    <p class="code">for (var i = 0; i &lt; player_lives; i += 1)
      <br />
      {
      <br />
      var _xx = gui_w - 48 - (i * 70);
      <br />
      draw_sprite(spr_Heart, 0, _xx, 48);
      <br />
      }
    </p>
    <p class="dropspot">Se non avete ancora aggiunto un'istanza di questo <span class="notranslate">object</span> a un <span class="notranslate">room</span> gioco, aggiungetelo ora (solo uno!), quindi premete il tasto <strong>Play </strong> <img>. Una volta avviato il gioco, premete varie volte il tasto <span class="inline">&lt;Enter&gt;</span> per vedere le vite cambiare.</p>
    <p class="dropspot"><img alt="Adding A Space Key Pressed Event" class="center" src="../assets/Images/QS_Guide/QS_Add_SpaceKeyPressEvent.png" /></p>
    <p class="dropspot">Prima di abbandonare questo esempio, si dovrebbe sperimentare con il numero di vite e vedere cosa succede. Al momento è impostato su 3, ma modificate l'evento Create e l'evento Key Pressed per impostare il valore a 5, o a 10... se avete fatto tutto bene, il codice dovrebbe adattarsi e disegnarle tutte correttamente!</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down7" href="#">Disegnare una barra della salute</a></p>
  <div class="droptext" data-targetname="drop_down7">
    <p class="dropspot">Questo ultimo esempio riguarda il disegno di una barra della salute nel livello GUI. Ci sono diversi modi per farlo, ma <span data-keyref="GameMaker Name">GameMaker</span> ha una funzione incorporata specificamente per le barre della salute, quindi è quella che useremo qui, anche se è possibile crearne una propria usando <span class="notranslate">sprites</span> o delle forme. Per iniziare, come prima, dobbiamo inizializzare un varaible per contenere il valore della salute, quindi aggiungiamo il seguente <span class="notranslate">GML</span> Visual o <span class="notranslate">GML</span> nell'<strong>evento Create</strong> di <span class="notranslate">object</span> (dopo qualsiasi altro codice già presente):</p>
    <p class="dropspot"><img alt="GML VisualActions In The Space Key Event" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_2.png" /></p>
    <p class="code">player_health = 100;</p>
    <p class="dropspot">Vogliamo usare i tasti freccia per modificare il valore della salute verso l'alto o verso il basso, a seconda del tasto freccia premuto. Potremmo farlo aggiungendo due eventi <strong>Keyboard Pressed &lt;Arrow&gt;</strong>, ma probabilmente è più semplice usare un <strong>evento Step</strong> e un po' di codice per controllare i tasti, quindi aggiungiamo subito un <strong>evento Step</strong> con il seguente <span class="notranslate">GML</span> Visual o GML:</p>
    <p class="dropspot"><img alt="Drawing Text To The GUI Layer Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_3.png" /></p>
    <p class="code">if keyboard_check(vk_up)<br />
      {<br />
          if (player_health &lt; 100) <br />
          {<br />
              player_health = player_health + 1;<br />
          }<br />
      }<br />
      <br />
      if (keyboard_check(vk_down)) <br />
      {<br />
          if (player_health &gt; 0) <br />
          {<br />
              player_health = player_health - 1;<br />
          }<br />
      }
    </p>
    <p class="dropspot">Fatto questo, possiamo passare a disegnare la barra della salute, cosa che si fa nell'evento Draw GUI, aggiungendo quanto segue (dopo tutto ciò che è già presente):</p>
    <p class="dropspot"><img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png" /></p>
    <p class="code">var _xx = display_get_gui_width() / 2;<br />
      <br />
      draw_healthbar(_xx - 50, 24, _xx + 50, 40, player_health, c_black, c_red, c_lime, 0, true, true);
    </p>
    <p class="dropspot">Aggiungete un'istanza di questo <span class="notranslate">object</span> a un <span class="notranslate">room</span> se non l'avete ancora fatto (solo una, però!), e poi premete il tasto <strong>Play </strong> <img>. Una volta che il gioco è in corso, premete varie volte i tasti <span class="inline">&lt;Up Arrow&gt;</span> e <span class="inline">&lt;Down Arrow&gt;</span> per vedere la salute cambiare.</p>
    <p class="dropspot"><img alt="Animation Showing Text Being Drawn To The GUI Layer" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_6.gif" /></p>
  </div>
  <p> </p>
  <p>Speriamo che dopo aver fatto questi esempi abbiate un po' più di fiducia nell'uso di <span data-keyref="GameMaker Name">GameMaker</span> e un po' più di comprensione di come funziona il tutto. La prossima sezione analizzerà come far muovere gli oggetti disegnati su <span class="notranslate">room</span> e come accettare e rispondere agli input dell'utente.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Indietro: <a href="../Content.htm">Indice</a></div>
        <div style="float:right">Avanti: <a href="Movement_And_Controls.htm">Movimento e controlli</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Tutti i diritti riservati</span></h5>
  </div>
  <!-- KEYWORDS
Drawing
Drawing Examples
Quick Start Drawing
-->
  <!-- TAGS
qs_drawing
-->
</body>
</html>