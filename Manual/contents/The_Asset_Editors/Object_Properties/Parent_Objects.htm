<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Oggetti genitori</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page detailing object parenting" />
  <meta name="rh-index-keywords" content="Objects - Parents" />
  <meta name="search-keywords" content="parent,child,inheritance,object parenting" />
  <link rel="stylesheet" type="text/css" href="../../assets/css/default.css" />
  <script src="../../assets/scripts/main_script.js"></script>
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Oggetti genitori</h1>
  <p>Quando si lavora con <span class="notranslate">objects</span> in <span data-keyref="GameMaker Name">GameMaker</span> <span class="notranslate">IDE</span>, è possibile impostare gerarchie <strong>genitore/figlio </strong>. Questo viene fatto cliccando il pulsante &quot;Genitore&quot; nell'editor <span class="notranslate">object</span> e poi scegliendo un altro <span class="notranslate">object</span> dal Browser <span class="notranslate">Asset</span> 
    per essere il &quot;genitore&quot; di quello che si sta modificando:</p>
  <p><img>Quindi, ogni <span class="notranslate">object</span> nel vostro progetto di gioco può avere un genitore <span class="notranslate">object</span>, ma cosa significa questo? Bene, quando un <span class="notranslate">object</span> ha un genitore assegnato può
    condividere codice, azioni ed eventi con quel genitore. Questa condivisione è chiamata &quot;ereditarietà&quot; e un <span class="notranslate">object</span> che ha un genitore è chiamato &quot;figlio&quot; <span class="notranslate">object</span>. Non solo un figlio può condividere codice con il suo genitore, ma è possibile fare controlli ed eseguire codice
    sul genitore <span class="notranslate">objects</span> e questo includerà automaticamente anche il figlio <span class="notranslate">objects</span>, il che fa risparmiare molto tempo ed energia.</p>
  <p>Se questo suona complicato, allora un altro modo di guardare a un genitore <span class="notranslate">object</span> è come un modo per &quot;raggruppare&quot; <span class="notranslate">objects</span> sotto lo stesso ombrello e fargli condividere certe cose senza perdere la propria identità unica. Forse questo ancora non
    chiarisce ancora troppo le cose, quindi facciamo qualche esempio...</p>
  <p>Diciamo che avete un &quot;giocatore&quot; <span class="notranslate">object</span> e quattro diversi &quot;nemici&quot; <span class="notranslate">objects</span>. Ora, volete che il giocatore muoia se tocca uno qualsiasi di questi quattro <span class="notranslate">objects</span> e questo normalmente comporterebbe quattro diversi eventi di collisione con quattro diversi set di
    azioni o codice, uno per ogni nemico <span class="notranslate">objects</span>. MA se creiamo un genitore <span class="notranslate">object</span> per tutti i nemici, allora possiamo creare un evento di collisione solo con il genitore <span class="notranslate">object</span> e si attiverà indipendentemente da quale dei quattro nemici &quot;figli&quot;
    <span class="notranslate">objects</span> tocchi il giocatore. Roba comoda! Nell'attuale <span data-keyref="GameMaker Name">GameMaker</span> <span class="notranslate">object</span> vedreste qualcosa del genere:</p>
  <p><img>Sulla sinistra abbiamo quattro eventi di collisione separati e sulla destra abbiamo un singolo evento di collisione, poiché abbiamo creato un
    &quot;genitore&quot; <span class="notranslate">object</span> e gli abbiamo assegnato tutti i nemici <span class="notranslate">objects</span>. Si noti che un genitore <span class="notranslate">object</span> non deve avere alcun evento o codice al suo interno...</p>
  <p>Un altro esempio di parenting sarebbe se avete un gioco in cui volete creare 10 diversi <span class="notranslate">objects</span> e farli comportare tutti allo stesso modo. Per questo si dovrebbe creare un genitore <span class="notranslate">object</span> e in esso avere tutte le azioni di comportamento o il codice
    negli eventi richiesti, e poi creereste i vostri dieci <span class="notranslate">objects</span> senza azioni o codice, ma diversi <span class="notranslate">sprites</span>, e li assegnereste al vostro genitore <span class="notranslate">object</span>. Ora, quando mettete queste istanze in un <span class="notranslate">room</span> si comporteranno tutte allo stesso modo, ma avranno un aspetto diverso,
    poiché &quot;erediteranno&quot; gli eventi del genitore.</p>
  <p>Infine si può usare il parenting per &quot;mescolare e abbinare&quot; eventi e comportamenti. Lo illustreremo con un ultimo esempio... Diciamo che volete due mostri: uno che si muove su e giù, mentre un altro che si muove a destra e sinistra, ma volete anche che i due
    due abbiano la stessa salute, sparino al giocatore e lo feriscano se si scontrano con loro. In questo caso potete vedere che quasi tutti gli eventi dovrebbero avere le stesse azioni tranne uno o due che governano il movimento. Quindi, di nuovo, possiamo fare
    un <span class="notranslate">object</span> il genitore dell'altro, ma in questo caso definiamo anche certi eventi per il figlio <span class="notranslate">object</span>. Questi eventi &quot;sovrascrivono&quot; gli eventi padre, il che significa che ogni volta che un evento per il figlio <span class="notranslate">object</span> contiene azioni, queste vengono eseguite
    invece delle azioni contenute nell'evento del genitore. Se vuoi eseguire anche l'evento del genitore puoi chiamare il cosiddetto evento &quot;ereditato&quot; usando la funzione <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Objects/Object_Events/event_inherited.htm"><span class="inline">event_inherited()</span></a>,
    o l'azione <span class="notranslate">GML</span> Visual <a href="../../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Call_Parent_Event.htm">Call Parent Event</a>.</p>
  <p><img>A sinistra in alto c'è il genitore <span class="notranslate">object</span> con 5 eventi in esso, e a destra si può vedere il &quot;figlio&quot; <span class="notranslate">object</span>. L'oggetto figlio
    ha anch'esso 5 eventi, ma due di essi sovrascrivono gli eventi ereditati dal genitore (gli eventi <strong>Step </strong>e <strong>Draw </strong>) e gli altri tre sono grigi perché sono gli eventi ereditati dal genitore. Gli eventi ereditati
    avranno anche l'icona &quot;parent override&quot; accanto a loro nell'Editor eventi:</p>
  <p><img>Quando clicchi su <img> su un evento che è stato ereditato,
    si aprirà l'editor di codice per mostrare il codice del genitore ereditato, ma non sarai in grado di modificare questo codice perché puoi modificarlo solo nel genitore <span class="notranslate">object</span> stesso. Puoi cliccare con il tasto destro del mouse <img> su qualsiasi evento genitore per aprire il seguente menu di opzioni:</p>
  <p><img>Qui potete scegliere due <strong>Aprire </strong>l'evento padre per ispezionare il codice, oppure potete scegliere di <strong>Ereditare </strong>l'evento
    o <strong>sovrascrivere </strong>l'evento. Se si sceglie <strong>Inherit </strong>allora l'editor di codice si aprirà con la funzione <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Objects/Object_Events/event_inherited.htm"><span class="inline">event_inherited()</span></a> già
    aggiunta (o l'azione <a href="../../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Call_Parent_Event.htm">Call Parent Event</a> se si usa <span class="notranslate">GML</span> Visual). Qualsiasi altro codice inserito in questo evento sarà ora eseguito così come il codice che l'oggetto genitore
    ha. Se scegliete di <strong>sovrascrivere </strong>l'evento, allora si aprirà anche la finestra del codice, solo che ora la funzione <span class="inline">event_inherited()</span> non sarà chiamata, quindi qualsiasi cosa aggiungiate qui sarà eseguita <em>al posto </em>del codice
    nel genitore <span class="notranslate">object</span>.</p>
  <p class="note"><strong>NOTA</strong>: Dall'editor di codice si può navigare rapidamente al genitore <span class="notranslate">object</span> cliccando il tasto destro del mouse <img> e selezionando <strong>Go To Object</strong> dal menu a comparsa, oppure (se l'evento è stato sovrascritto) si può selezionare <strong>Open Inherited Event</strong> per andare direttamente a un editor di codice con il codice dell'evento genitore.</p>
  <p>Ogni volta che nel codice si prende di mira un genitore <span class="notranslate">object</span>, il codice si applica anche ai &quot;figli&quot; del genitore <span class="notranslate">object</span>. Questo accade quando, in un'azione, si indica che l'azione deve essere applicata alle istanze di un certo <span class="notranslate">object</span>, e nel codice
    succede quando si usa l'istruzione <a href="../../GameMaker_Language/GML_Overview/Language_Features/with.htm"><span class="inline">with()</span></a> dichiarazione. Funziona così anche quando si chiamano funzioni del codice, come <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Instances/instance_position.htm"><span class="inline">instance_position()</span></a>,
    <a href="../../GameMaker_Language/GML_Reference/Asset_Management/Instances/instance_number.htm"><span class="inline">instance_number()</span></a>, ecc... dove - se fornite un genitore <span class="notranslate">object</span> - tutte le istanze del genitore <em>e del </em>figlio
    saranno incluse nei controlli. Infine, il parenting funziona anche quando si fa riferimento a variabili in altri <span class="notranslate">objects</span>, come nell'esempio del mostro di cui sopra, se imposto la velocità del nemico 1 a 10, allora anche la velocità del nemico 2 andrà a dieci perché è un figlio <span class="notranslate">object</span> del nemico
    1.</p>
  <p>È generalmente considerato una buona pratica nella maggior parte dei casi creare un genitore di base <span class="notranslate">object</span> e fare in modo che questo <span class="notranslate">object</span> contenga tutti i comportamenti predefiniti, ma non usarne mai un'istanza nel gioco. Piuttosto usate tutti i figli <span class="notranslate">objects</span> e usate il genitore solo in
    situazioni come quelle che ho delineato sopra, per le collisioni, per referenziare le variabili, ecc... Dovreste anche rendervi conto che anche i genitori possono avere dei genitori! Ovviamente non puoi creare un ciclo di &quot;il genitore 1 è figlio del genitore 2 è figlio del genitore
    1&quot; ma puoi creare quella che si chiama &quot;gerarchia di oggetti&quot; dove &quot;il<em>genitore3 </em>è figlio del <em>genitore2 </em>è figlio del <em>genitore1</em>&quot;. Questo è estremamente utile per mantenere il vostro gioco strutturato e si consiglia vivamente
    di imparare ad usare questo meccanismo.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Indietro: <a href="../Objects.htm">Il <span class="notranslate">Object</span> Editor</a></div>
        <div style="float:right">Prossimo: <a href="Physics_Objects.htm">Oggetti di fisica</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Tutti i diritti riservati</span></h5>
  </div>
  <!-- KEYWORDS
Parent Objects
Child Objects
parent
child
inheritance
-->
  <!-- TAGS
parent_objects
-->
</body>
</html>