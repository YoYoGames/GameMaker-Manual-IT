<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Array</title>
  <meta name="generator" content="Adobe RoboHelp 2020" />
  <link rel="stylesheet" href="../../assets/css/default.css" type="text/css" />
  <script src="../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Page outlining Arrays" />
  <meta name="rh-index-keywords" content="Arrays" />
  <meta name="search-keywords" content="Arrays" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>Array</h1>
  <p>Gli array possono essere estremamente utili e sono una parte essenziale della creazione di giochi. È essenzialmente un tipo di variabile che può contenere più valori come una &quot;lista&quot; -- considerate il seguente codice:</p>
  <p class="code">numbers = [ 0, 1, 2, 3, 4, 5 ];<br />
    <br />
    fruits = [ &quot;Apples&quot;, &quot;Oranges&quot;, &quot;Mangoes&quot; ];
  </p>
  <p>Usando la sintassi <span class="inline2">[item, item, item]</span> stiamo creando un array che viene memorizzato in una variabile. Gli elementi memorizzati in una matrice possono in seguito essere raggiunti attraverso quella variabile utilizzando un numero intero, a partire da <span class="inline">0</span>, che è posto all'interno delle parentesi <span class="inline2">[]</span>:</p>
  <p class="code">first_fruit = fruits[ 0 ];<br />
    second_fruit = fruits[ 1 ];<br />
    // ...and so on.</p>
  <p><label for="aone">Un array di base è classificato come avente 1 <strong>dimensione</strong>, ma si possono avere anche array con più di una dimensione. Le sezioni seguenti spiegano entrambi i tipi di array:</label></p>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#">Array 1-Dimensionale</a></p>
  <div class="droptext" data-targetname="drop-down1">
    <p class="dropspot">Prima di andare avanti chiariamo cos'è un array e come è strutturato. Un array è semplicemente un <a href="Data_Types.htm">tipo di dati</a> che viene assegnato ad una variabile, e può contenere non solo un valore, ma più valori. L'immagine qui sotto mostra uno schema di un array di base:</p>
    <p class="dropspot"><img class="center" src="../../assets/Images/Scripting_Reference/GML/Overview/1DArrayExample.png" /></p>
    <p class="dropspot">Questo è chiamato un array <strong>1D</strong> (unidimensionale), e come potete vedere l'array è memorizzato nella variabile &quot;<span class="inline">a</span>&quot; e contiene più valori. Per accedere all'array dovreste fare qualcosa di simile a quanto segue:</p>
    <p class="code">var _val = a[0];<br />
      show_debug_message(_val);</p>
    <p class="dropspot">Il codice di cui sopra ottiene il valore dalla posizione 0 dell'array &quot;<span class="inline">a</span>&quot; poi lo invia in uscita alla console, che - in base al contenuto dell'array mostrato nell'immagine sopra - emetterebbe 125. Se avete fatto quanto segue:</p>
    <p class="code">var _val = a[3];<br />
      show_debug_message(_val);</p>
    <p class="dropspot">L'output mostrerebbe &quot;Ciao!</p>
    <p class="dropspot">Come potete vedere, date all'array un nome di variabile e poi un valore tra parentesi quadre <span class="inline">[]</span>, dove il valore è la posizione nell'array da cui prendere i dati. Quindi, essenzialmente, un array è un contenitore con un certo numero di slot per memorizzare valori, e ogni posizione nel contenitore ha un numero specifico per identificarlo, che è quello che abbiamo messo nel <span class="inline">[]</span>. Vale la pena notare che il contenuto di un array <b>inizia sempre da 0</b> e <i>non</i>può <i>mai essere negativo</i><em>!</em></p>
    <h3 class="dropspot">       Creare gli array</h3>
    <p class="dropspot">Abbiamo mostrato come controllare un array per i dati, ma come facciamo a creare l'array per iniziare? Innanzitutto deve essere <i>inizializzato</i> prima di poterlo utilizzare, altrimenti <span data-keyref="GameMaker Name">GameMaker</span> ci darà un errore. Inizializzare un array significa semplicemente che diamo ad ogni slot dell'array un valore iniziale in preparazione per essere usato altrove nel codice del progetto. Questo è importante da ricordare perché significa che dovete fare una certa quantità di pianificazione prima di usare gli array, ma è abbastanza facile inizializzarne uno usando una ripetizione <span class="notranslate">loop</span> come questa:</p>
    <p class="code">var i = 9;<br /><br />
      repeat(10)<br />
      {<br />
          array[i] = 0;<br />
          i -= 1;<br />
      }</p>
    <p class="dropspot">Questo semplice codice inizializzerà un array di dieci slot (da 0 a 9) per contenere 0, cioè: ogni slot nell'array contiene il valore 0. Noterete che l'array è stato inizializzato <i>al contrario</i>, con l'ultimo valore definito per primo. Questo non è strettamente necessario, ma è il modo ottimale per farlo in quanto riserva uno spazio in memoria che è l'esatta dimensione dell'array, mentre se inizializzate un array da 0 <em>in su</em>, la memoria deve essere riallocata per ogni valore aggiunto (quindi per un array di dieci slot, inizializzarlo in un <span class="notranslate">loop</span> cambierebbe l'allocazione della memoria dieci volte). La differenza di velocità è trascurabile per gli array più piccoli, ma quelli più grandi dovrebbero essere ottimizzati il più possibile in questo modo.</p>
    <p class="note"><b>NOTA</b>: l'esportazione HTML5 è l'eccezione alla regola di cui sopra, e quando si punta a questo si dovrebbero inizializzare gli array in ordine consecutivo da 0 in su.</p>
    <p class="dropspot">Potete anche usare la funzione <span class="notranslate">GML</span> <a href="../GML_Reference/Variable_Functions/array_create.htm"><span class="inline">array_create()</span></a> per inizializzare un array con una dimensione fissa, e potete anche creare array &quot;vuoti&quot; <em>senza</em> valori, per esempio:</p>
    <p class="code">my_array = [];</p>
    <p class="dropspot">Questo dice a <span class="notranslate">GameMaker</span> che la variabile &quot;<span class="inline">my_array</span>&quot; è un array, e potete quindi <a href="../GML_Reference/Variable_Functions/array_push.htm">aggiungere valori</a> ad esso in qualsiasi momento in futuro. Tuttavia, se provate ad accedere ad un valore in un array vuoto, otterrete un errore.<br></p>
    <p class="dropspot">Se sapete già quali elementi volete mettere nell'array, potete aggiungere valori separati da virgole tra le parentesi quando dichiarate l'array:</p>
    <p class="code">my_array = [&quot;Steve&quot;, 36, &quot;ST-3V3 - Steve Street&quot;];</p>
    <h3 class="dropspot">       Limiti della matrice</h3>
    <p class="dropspot">Dovreste sempre fare attenzione ad accedere solo a posizioni valide dell'array, poiché anche il tentativo di accedere ad un valore al di fuori di un array darà un errore. Per esempio, questo causerà il crash del progetto quando viene eseguito:</p>
    <p class="code">my_array = array_create(5, 0);<br />
      var _val = my_array[6];</p>
    <p class="dropspot">L'array è stato inizializzato solo con 5 posizioni, ma abbiamo cercato di ottenere la posizione 7 - poiché gli array sono numerati da 0, <span class="inline">array[6]</span> è la posizione 7 - quindi il gioco genera un errore e va in crash.</p>
    <h3 class="dropspot">       Usare gli array</h3>
    <p class="dropspot">Ora come usiamo praticamente un array? Esattamente come useremmo una normale variabile, come mostrato nei seguenti esempi:</p>
    <p class="code">// Add two array values together<br />
      total = array[0] + array[5];<br />
      <br />
      // Check an array value<br />
      if (array[9] == 10)<br />
      {<br />
          // Do something<br />
      }<br />
      <br />
      // Draw an array value<br />
      draw_text(32, 32, array[3]);
    </p>
    <p class="dropspot">Dato che gli array sono numerati in modo sequenziale, questo significa che potete <span class="notranslate">loop</span> attraverso di loro per eseguire anche azioni extra, proprio come abbiamo fatto per inizializzarlo:</p>
    <p class="code">var total = 0;<br />
      <br />
      for (var i = 0; i &lt; 10; ++i)<br />
      {<br />
          _total += array[i];<br />
          draw_text(32, 32 + (i * 32), array[i]);<br />
      }<br />
      <br />
      draw_text(32, 32 + (i * 32), _total);
    </p>
    <p class="dropspot">Il codice qui sopra aggiungerà tutti i valori nella nostra matrice, disegnerà ognuno di loro e poi disegnerà il valore totale alla fine.</p>
    <h3 class="dropspot">       Cancellare gli array</h3>
    <p class="dropspot">L'ultima cosa da menzionare sugli array è che potete cancellare un array semplicemente &quot;riassegnando&quot; la variabile che lo definisce ad un singolo valore. Questo libererà la memoria associata a tutte le posizioni e valori di quell'array. Per esempio:</p>
    <p class="code">// Create an array<br />for (var i = 9; i &gt; -1; --i)<br />
      {<br />
          a[i] = i;<br />
      }<br />
      <br />
      // Delete the array<br />
      a = -1;
    </p>
    <p class="dropspot">Se l'array ha più dimensioni (vedi sotto), anch'esse saranno ripulite, e nota che quando crei array nelle istanze, queste non hanno bisogno di essere ripulite quando l'istanza viene rimossa dal gioco, poiché saranno rimosse automaticamente dal <a class="glossterm" data-glossterm="collettore di rifiuti" href="#">garbage collector</a> su Destroy o <span class="notranslate">Room</span> End. Tuttavia, se una qualsiasi posizione dell'array contiene riferimenti a risorse <em>dinamiche</em>, come sistemi di particelle, <span class="notranslate">buffers</span>, o strutture dati, allora queste dovranno <em>essere</em> distrutte prima che l'array venga cancellato, l'istanza venga distrutta o il <span class="notranslate">room</span> termini.</p>
    <p class="dropspot"> </p>
  </div>
  <p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#">Array multidimensionali</a></p>
  <div class="droptext" data-targetname="drop-down2">
    <p class="dropspot"><span style="text-align: justify;">Ora sappiamo cos'è un array a 1 dimensione, ma in <span data-keyref="GameMaker Name">GameMaker</span> si possono avere array con più dimensioni, che sono essenzialmente strutturati come un array dentro un array dentro un array... Per esempio, il seguente è un array <strong>2D</strong> (bidimensionale):</span></p>
    <p class="code">array[0][0] = 5;</p>
    <p class="dropspot">Questo è essenzialmente dire a <span class="notranslate">GameMaker</span> che l'array è in realtà composto da vari array 1D. Ecco un esempio esteso:</p>
    <p class="code">array<strong>[0]</strong>[0] = 0;<br />
      array<strong>[0]</strong>[1] = 1;<br />
      array<strong>[0]</strong>[2] = 2;<br />
      <br />
      array<strong>[1]</strong>[0] = 3;<br />
      array<strong>[1]</strong>[1] = 4;<br />
      <strong></strong>array<strong>[1]</strong>[2] = 5;
    </p>
    <p class="dropspot">Nel codice precedente, <span class="inline">array[0]</span> contiene un'altra matrice, e così anche <span class="inline">array[1]</span>.</p>
    <p class="dropspot">Un array multidimensionale ha bisogno di essere inizializzato prima dell'uso, lo stesso di un singolo array 1D, e può contenere numeri reali, <span class="notranslate">strings</span>, e qualsiasi altro <a href="Data_Types.htm">tipo di dati</a>, proprio come qualsiasi variabile, rendendoli candidati ideali per qualsiasi gioco che ha bisogno di memorizzare grandi quantità di dati in un modo facilmente accessibile (ricordate, è possibile <span class="notranslate">loop</span> attraverso un array facilmente).</p>
    <p class="dropspot">Potete anche inizializzare un array multidimensionale all'interno di una dichiarazione annidando array 1-dimensionali:</p>
    <p class="code">two_dimensional_array = <br />
      [<br />
          [&quot;Apple&quot;, 10, 2],<br />
          [&quot;Orange&quot;, 5, 2],<br />
          [&quot;Mango&quot;, 15, 4],<br />
          // ...and so on.<br />
      ]</p>
    <p class="dropspot">Gli array multidimensionali non sono anche limitati a due <em>sole </em>dimensioni, e potete avere 3, 4 o più dimensioni per un array come richiesto nel vostro codice, semplicemente aggiungendo <span class="inline">[n]</span> ulteriori argomenti, ad esempio:</p>
    <p class="code">array[0][0][0] = 1;     // A three dimensional array<br />
      array[0][0][0][0] = 1;  // A four dimensional array<br />
      // etc...</p>
    <p class="dropspot">Bisogna anche notare che la lunghezza di ogni dimensione in una matrice può essere diversa, quindi si può avere la dimensione iniziale della matrice con una lunghezza di 3, ma la seconda dimensione può avere una lunghezza diversa per ogni slot nella prima dimensione; per esempio:</p>
    <p class="code">array[2][2] = &quot;3&quot;;<br />
      array[2][1] = &quot;2&quot;;<br />
      array[2][0] = &quot;1&quot;;<br />
      <br />
      array[1][3] = &quot;four&quot;;<br />
      array[1][2] = &quot;three&quot;;<br />
      array[1][1] = &quot;two&quot;;<br />
      array[1][0] = &quot;one&quot;;<br />
      <br />
      array[0][1] = 2;<br />
      array[0][0] = 1;
    </p>
    <p class="dropspot">Nel codice precedente, <span class="inline">array[0]</span> ha 2 slot, <span class="inline">array[1]</span> ha 4 slot e <span class="inline">array[2]</span> ha 3 slot.</p>
    <h3 class="dropspot">       Esempio esteso</h3>
    <p class="dropspot">Ecco un ultimo esempio di come questo può essere usato in un gioco reale: Diciamo che volete generare quattro nemici diversi in quattro punti diversi del vostro gioco a seconda di un valore casuale. Bene, possiamo usare un array con 2 dimensioni per farlo e risparmiare di scrivere un sacco di codice.</p>
    <p class="dropspot">Per prima cosa dovremmo inizializzare l'array che useremo nell'evento Create del nostro &quot;controller&quot; <span class="notranslate">object</span> (notate l'uso dei commenti per ricordarvi cosa fa ogni voce dell'array):</p>
    <p class="code">enemy[3][2] = 448;       //y position<br />
      enemy[3][1] = 32;        //x position<br />
      enemy[3][0] = obj_Slime; //Object<br />
      enemy[2][2] = 448;<br />
      enemy[2][1] = 608;<br />
      enemy[2][0] = obj_Skeleton;<br />
      enemy[1][2] = 32;<br />
      enemy[1][1] = 608;<br />
      enemy[1][0] = obj_Knight;<br />
      enemy[0][2] = 32;<br />
      enemy[0][1] = 32;<br />
      enemy[0][0] = obj_Ogre;</p>
    <p class="dropspot">Ora abbiamo il <span class="notranslate">objects</span> di cui spawnare le istanze e le loro corrispondenti coordinate di spawn x e y all'interno del <span class="notranslate">room</span> tutto memorizzato nel nostro array. Questo può ora essere usato come segue in un altro evento del controller <span class="notranslate">object</span> (un allarme per esempio, o un evento di pressione dei tasti):</p>
    <p class="code">//get a random number from 0 to 3, inclusive<br />
      var i = irandom(3);<br />
      <br />
      //Use the array to create the object<br />
      instance_create_layer(enemy[i][1], enemy[i][2], &quot;Enemy_Layer&quot;, enemy[i][0]);
    </p>
    <p class="dropspot">Questo breve codice ora genererà un nemico casuale nel gioco <span class="notranslate">room</span>, e usa molto meno codice di una struttura &quot;<span class="inline">if / then / else</span>&quot; o anche un &quot;<span class="inline">switch</span>&quot;, e poiché l'array è inizializzato tutto insieme nell'evento di creazione è MOLTO più facile da modificare e cambiare qualsiasi di quei valori poiché non sono <a class="glossterm" data-glossterm="hard-coded" href="#">hard-coded</a> nel resto del codice del progetto.</p>
  </div>
  <p> </p>
  <h2>Array come argomenti di funzione</h2>
  <p>Potete passare degli array nelle <a href="Script_Functions.htm">funzioni di script</a> e nelle <a href="Method_Variables.htm">variabili di metodo</a> come argomenti, e modificare quegli array ovunque all'interno della funzione. Facendo questo, si modificheranno anche gli array originali.</p>
  <p>Per esempio, questa funzione cambia semplicemente i primi tre elementi dell'array passato in essa:</p>
  <p class="code">modify_array = function (array)<br />
    {<br />
        array[0] = 2;<br />
        array[1] = 4;<br />
        array[2] = 6;<br />
    }</p>
  <p>Ora potete creare un array e passarlo in questa funzione, che modificherà l'array:</p>
  <p class="code">my_array = [100, 4, 214];<br />
    <br />
    modify_array(my_array);<br />
    <br />
    show_debug_message(my_array); // Prints [2, 4, 6];
  </p>
  <p>Nelle versioni precedenti di <span class="notranslate">GameMaker</span>, questo non era il caso, poiché la modifica di un array all'interno di una funzione creava invece una copia. Questo comportamento <em>deprecato</em> può ancora essere abilitato, se lo si desidera: leggere la sezione &quot;<strong>Copy on Write</strong>&quot; qui sotto per maggiori informazioni.</p>
  <h2 id="h">Copiare su Write</h2>
  <p>Il comportamento di Copy on Write è deprecato ed è usato solo quando &quot;<strong>Enable Copy on Write behaviour for Arrays</strong>&quot; è abilitato nelle <a href="../../Settings/Game_Options.htm">General Game Options</a>. Questa sezione descrive il comportamento degli array quando questa opzione è abilitata.</p>
  <p>Come descritto nella sezione precedente, gli array possono essere passati nelle funzioni come argomenti. Per fare questo, dovete semplicemente specificare la variabile dell'array (non c'è bisogno di ogni singola posizione, né delle parentesi <span class="inline">[]</span> ) e l'intero array verrà <b>passato per riferimento</b> nella funzione:</p>
  <p class="code">my_array = [1, 2, 4, 8, 16];<br />
    <br />
    do_something(my_array);
  </p>
  <p>Tuttavia, quando <strong>Copy on Write</strong> è abilitato, cambiando qualsiasi valore dell'array all'interno della funzione si crea una copia temporanea con le vostre modifiche. L'array originale non viene modificato. Questo comportamento è chiamato Copy on Write.</p>
  <p>Per modificare effettivamente l'array originale che è stato passato nella funzione, dovete restituirlo o usare l'accessor <span class="inline">@</span>.</p>
  <p>Per esempio, la funzione chiamata sopra, <span class="inline2">do_something()</span>, può fare qualcosa di semplice come questo:</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[1] = 200;<br />
    }</p>
  <p>Ora vi aspettereste che <span class="inline2">my_array</span> tenga i valori <span class="inline2">1, 200, 4</span>, ecc., il che sarebbe normalmente corretto -- ma quando <strong>Copy on Write</strong> è abilitato, l'array originale rimane inalterato.</p>
  <p>Per aggirare questo problema, potete fare in modo che la funzione <strong>restituisca</strong> la copia modificata dell'array, e poi applicarla di nuovo alla variabile originale:</p>
  <p class="code">my_array = [1, 2, 4, 8, 16];<br />
    <br />
    my_array = do_something(my_array);
  </p>
  <p>La funzione stessa restituirebbe l'array modificato:</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[1] = 200;<br />
    <br />
        return array;<br />
    }
  </p>
  <p class="note"><span class="note">NOTA</span><b> </b>Il codice di cui sopra non è necessario se non state cambiando nessuno dei valori dell'array, ma piuttosto facendo riferimento ad essi. Fare riferimento ad un array non lo copierà e sarà più veloce da analizzare.</p>
  <p>La seconda soluzione è di usare l'accessor <span class="inline">@</span> per cambiare direttamente i valori dell'array, il che risparmia l'overhead della CPU di dover fare una copia temporanea. Questo significa che non avete bisogno di restituire l'array dalla funzione e potete modificarlo direttamente:</p>
  <p class="code">do_something = function(array)<br />
    {<br />
        array[@ 1] = 200;<br />
    }</p>
  <p>L'utilizzo di questo accessor bypassa il comportamento di Copy on Write e modifica direttamente l'array referenziato. Questo può essere usato per disabilitare selettivamente Copy on Write per dichiarazioni specifiche, mantenendo l'opzione abilitata.</p>
  <p>Di nuovo, tutto questo non è necessario se <strong>Copy on Write</strong> è <strong>disabilitato</strong> (che è l'opzione predefinita e raccomandata).</p>
  <p>Trovate maggiori informazioni sugli accessor e su come funzionano, insieme ad un esempio per gli array, nella pagina seguente:</p>
  <ul class="colour">
    <li><a href="Accessors.htm">Accessori</a></li>
  </ul>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Indietro: <a href="GML_Overview.htm">Panoramica GML</a></div>
        <div style="float:right">Avanti: <a data-xref="{title}" href="Structs.htm">Strutture e costruttori</a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2022 Tutti i diritti riservati</span></h5>
  </div>
  <!-- KEYWORDS
Arrays
passing arrays to scripts
deleting arrays
-->
  <!-- TAGS
arrays
-->
</body>
</html>