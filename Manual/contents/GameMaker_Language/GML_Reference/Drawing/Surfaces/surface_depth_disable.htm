<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>superficie_profondità_disabilita</title>
  <meta name="generator" content="Adobe RoboHelp 2019" />
  <link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css" />
  <script src="../../../../assets/scripts/main_script.js"></script>
  <meta name="rh-authors" content="Mark Alexander" />
  <meta name="topic-comment" content="Reference for surface_depth_disable" />
  <meta name="rh-index-keywords" content="surface_depth_disable" />
  <meta name="search-keywords" content="surface_depth_disable" />
</head>
<body>
  <!--<div class="body-scroll" style="top: 150px;">-->
  <h1>superficie_profondità_disabilita</h1>
  <p>Questa funzione disabilita la generazione automatica della profondità <span class="notranslate">buffer</span> per <i>tutte le</i> superfici che vengono create dopo che è stata disabilitata. Normalmente tutte le superfici hanno profondità <span class="notranslate">buffers</span> quindi se si disegna 3D <span class="notranslate">objects</span> su di esse, allora le ordinerà correttamente in base alla profondità in
    al fine di mantenere la parità funzionale tra il rendering sulle superfici e il rendering sul retro <span class="notranslate">buffer</span>, tuttavia allocare la profondità <span class="notranslate">buffers</span> essenzialmente raddoppia la quantità di memoria richiesta per le superfici, che potrebbe essere un overhead eccessivo e non necessario
    specialmente se il vostro gioco è molto intensivo in termini di memoria, e per i giochi 2D generalmente non sono necessari.</p>
  <p>Per usare questa funzione dovreste chiamarla <i>prima di</i> creare una superficie, e poi potete abilitarla di nuovo dopo (se necessario). Tutte le superfici create quando la profondità <span class="notranslate">buffer</span> è disabilitata non useranno più una profondità <span class="notranslate">buffer</span> quando vengono disegnate, questo risulta
    Questo si traduce nel fatto che le cose che vengono disegnate sulla superficie hanno la parità di profondità. Le immagini qui sotto illustrano questo in pratica:</p>
  <p><img>Nell'immagine qui sopra, stiamo disegnando un rettangolo e un triangolo usando un vertice <span class="notranslate">buffer</span> in 3D. Le
    coordinate per il triangolo rosso lo collocano dietro il rettangolo verde, ma il codice per disegnare il triangolo è chiamato <i>dopo il</i> codice per il rettangolo, e quando la profondità <span class="notranslate">buffer</span> è abilitata, il triangolo è ancora disegnato dietro il rettangolo
    poiché la profondità 3D viene rispettata. Tuttavia quando disabilitiamo la profondità <span class="notranslate">buffer</span> per la superficie, solo l'ordine del codice viene rispettato e quindi il triangolo viene disegnato sopra il rettangolo.</p>
  <p class="note"><b>NOTA</b>: per preservare correttamente la profondità in 3D quando si usano le superfici, non solo si dovrebbe avere la profondità <span class="notranslate">buffer</span> abilitata, ma si dovrebbe anche avere z-writing e z-testing abilitati. Vedere le funzioni <a href="../GPU_Control/gpu_get_ztestenable.htm"><span class="inline"><span style="font-size:14px;">gpu_set_ztestenable()</span></a>    e <a href="../GPU_Control/gpu_get_zwriteenable.htm"><span class="inline"><span style="font-size:14px;">gpu_set_zwriteenable()</span></a> per maggiori informazioni.</p>
  <p class="note"><b>NOTA</b>: se il vostro gioco è 100% 2D o sapete che non avete bisogno di una profondità di superficie <span class="notranslate">buffer</span>, allora dovrebbe andare bene chiamare semplicemente questa funzione una volta all'inizio del gioco per disabilitare il <span class="notranslate">buffer</span>.</p>
  <p> </p>
  <h4>Sintassi:</h4>
  <p class="code">surface_depth_disable(disable);</p>
  <table>
    <tbody>
      <tr>
        <th>Argomento</th><th>Tipo</th>
        <th>Descrizione</th>
     </tr>
      <tr>
        <td><span class="notranslate">disable</span></td><td><span data-keyref="Type_Bool"></span></td>
        <td><span class="notranslate">If set to <span class="inline">true</span> il buffer di profondità sarà disabilitato per le superfici create.</td>
     </tr>
    </tbody>
  </table>
  <p> </p>
  <h4>Ritorna:</h4>
  <p class="code"><span data-keyref="Type_Void"></span></p>
  <p> </p>
  <h4>Esempio:</h4>
  <p class="code">var _depth_setting = surface_get_depth_disable();<br/> surface_depth_disable(false);
    <br/> surface_with_depth = surface_create(room_width, room_height);<br/> surface_depth_disable(true);
    <br/> surface_without_depth = surface_create(room_width, room_height);<br/> surface_depth_disable(_depth_setting);
  </p>
  <p>Il codice qui sopra memorizza l'impostazione corrente della profondità <span class="notranslate">buffer</span> in una variabile e poi crea due superfici, una con il depth buffering abilitato e una senza, prima di ripristinare nuovamente l'impostazione originale.</p>
  <p> </p>
  <p> </p>
  <p> </p>
  <div class="footer">
    <div class="buttons">
      <div class="clear">
        <div style="float:left">Indietro: <a href="Surfaces.htm">Superfici</a></div>
        <div style="float:right">Il prossimo: <a href="surface_get_height.htm"><span class="notranslate">surface_get_height</span></a></div>
      </div>
    </div>
    <h5><span data-keyref="Copyright Notice">© Copyright <span class="notranslate">YoYo Games Ltd.</span> 2021 Tutti i diritti riservati</span></h5>
  </div>
  <!-- KEYWORDS
surface_depth_disable
-->
  <!-- TAGS
surface_depth_disable
-->
</body>
</html>